---
layout: post
title: Obsidian ç¡çœ è‡ªåŠ¨åŒ–ç»ˆææŒ‡å—ï¼šä¸€é”®è¿½è¸ªä¸å¯è§†åŒ–
date: 2025-09-15
categories:
  - Obsidian
tags:
  - Obsidian
  - Dataview
  - Templater
  - ç¡çœ ç›‘æµ‹
---
å¤§å®¶å¥½ï¼å¦‚æœä½ ä¹Ÿåœ¨ä¸ºè®°å½•ç¡çœ æ—¶é—´è€Œçƒ¦æ¼â€”â€”æ¯å¤©æ‰‹åŠ¨è¾“å…¥ã€è®¡ç®—æ—¶é•¿ï¼Œè¿˜å¾—è´¹åŠ›åœ°åˆ†ææ•°æ®â€”â€”é‚£ä¹ˆè¿™ç¯‡æ–‡ç« å°±æ˜¯ä¸ºä½ é‡èº«æ‰“é€ çš„ã€‚æˆ‘æ›¾ç»èŠ±äº†æ•°å°æ—¶è¸©éäº†å„ç§å‘ï¼Œæœ€ç»ˆæ­å»ºå‡ºè¿™å¥—**â€œæ™ºèƒ½â€**çš„Obsidianç¡çœ è¿½è¸ªç³»ç»Ÿã€‚

ç°åœ¨ï¼Œæˆ‘å°†ä¸€æ­¥æ­¥å¸¦ä½ å®ç°å®ƒã€‚åªéœ€15åˆ†é’Ÿï¼Œä½ å°±èƒ½äº«å—åˆ°**â€œä¸€ä¸ªæŒ‰é”®ï¼Œæå®šç¡è§‰ã€èµ·åºŠä¸å¤±çœ ä¿®æ­£â€**çš„æè‡´ä¾¿åˆ©ï¼Œä»¥åŠè‡ªåŠ¨ç”Ÿæˆçš„ç²¾ç¾ç¡çœ æ•°æ®å¯è§†åŒ–å›¾è¡¨ã€‚

ä¸ºä»€ä¹ˆé€‰æ‹©Obsidianï¼Ÿå®ƒå…è´¹ã€å¼€æºã€æ”¯æŒæ’ä»¶æ‰©å±•ï¼Œèƒ½å°†ä½ çš„ç¬”è®°åº“è½¬åŒ–ä¸ºå¼ºå¤§çš„ä¸ªäººæ•°æ®ç®¡ç†ç³»ç»Ÿã€‚è·Ÿéšæˆ‘çš„æŒ‡å—ï¼Œä½ å°†å­¦ä¼šå¦‚ä½•çœŸæ­£è®©å·¥å…·ä¸ºä½ æœåŠ¡ã€‚å‡†å¤‡å¥½äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å§ï¼

## æœ€ç»ˆæ•ˆæœé¢„è§ˆï¼ˆæ•ˆæœå›¾åœ¨åº•éƒ¨ï¼‰

æƒ³è±¡ä¸€ä¸‹è¿™æ ·çš„åœºæ™¯ï¼š
1.  **æ™šä¸Šå‡†å¤‡ç¡è§‰æ—¶**ï¼šæŒ‰ä¸€ä¸ªå¿«æ·é”®ï¼Œç³»ç»Ÿè‡ªåŠ¨åœ¨ä½ çš„ç¡çœ æ—¥è®°ä¸­æ·»åŠ ä¸€è¡Œè®°å½•ï¼Œå¦‚ `- [date:: 2025-09-08], [bed:: 23:58], [wake:: ]`ã€‚å®ƒç”šè‡³èƒ½æ™ºèƒ½åˆ¤æ–­å‡Œæ™¨ç¡è§‰ï¼ˆä¾‹å¦‚å‡Œæ™¨3ç‚¹ï¼‰ï¼Œå¹¶å°†æ—¥æœŸå½’ä¸ºå‰ä¸€å¤©ã€‚
2.  **å¤±çœ æˆ–æ™šç¡æ—¶**ï¼šä¸ŠåºŠåè¿‡äº†1ã€2ä¸ªå°æ—¶æ‰ç¡ç€ï¼Ÿæ²¡å…³ç³»ï¼Œå†æ¬¡æŒ‰ä¸‹**åŒä¸€ä¸ªå¿«æ·é”®**ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ¤æ–­æ—¶é—´å·®è¿‡çŸ­ï¼Œå°†ä½ çš„å…¥ç¡æ—¶é—´**é™é»˜ä¿®æ­£**ä¸ºå½“å‰æ—¶é—´ã€‚
3.  **æ—©ä¸Šèµ·åºŠæ—¶**ï¼šå†æ¬¡æŒ‰ä¸‹**åŒä¸€ä¸ªå¿«æ·é”®**ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ¤æ–­ä½ å·²ç¡äº†è¶³å¤Ÿé•¿çš„æ—¶é—´ï¼Œæ‰¾åˆ°æ˜¨æ™šçš„è®°å½•ï¼Œè¡¥å…¨èµ·åºŠæ—¶é—´ï¼Œå¹¶ç²¾ç¡®è®¡ç®—å‡ºç¡çœ æ—¶é•¿ï¼Œå¦‚ `- [date:: 2025-09-08], [bed:: 23:58], [wake:: 08:15], [duration:: 08:17]`ã€‚
4.  **æ•°æ®å¯è§†åŒ–**ï¼šåœ¨ä»»æ„ç¬”è®°ä¸­ï¼Œéƒ½èƒ½çœ‹åˆ°è‡ªåŠ¨ç”Ÿæˆçš„ç¡çœ æ—¶é•¿è¶‹åŠ¿å›¾ã€å¹³å‡å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒå›¾ï¼Œä»¥åŠæŒ‰æœˆ/å¹´ç»Ÿè®¡è¡¨æ ¼ã€‚æ‰€æœ‰æ•°æ®å®æ—¶æ›´æ–°ï¼Œä¸€ç›®äº†ç„¶ã€‚

è¿™ä¸ä»…ä»…æ˜¯è®°å½•ï¼Œæ›´æ˜¯å¸®åŠ©ä½ ä¼˜åŒ–ç¡çœ ã€æå‡ç”Ÿæ´»è´¨é‡çš„å¼ºå¤§å·¥å…·ã€‚

## æ‰€éœ€å·¥å…·

- [Obsidian](https://obsidian.md/)ï¼ˆå…è´¹ä¸‹è½½è‡ªå®˜ç½‘ï¼‰ã€‚
- **æ’ä»¶**ï¼ˆåœ¨Obsidianè®¾ç½® > ç¤¾åŒºæ’ä»¶ä¸­å®‰è£…å¹¶å¯ç”¨ï¼‰ï¼š
  - **Templater**ï¼šæ ¸å¿ƒæ’ä»¶ï¼Œç”¨äºè¿è¡Œæˆ‘ä»¬çš„â€œæ™ºèƒ½è„šæœ¬â€ï¼Œå®ç°è‡ªåŠ¨åŒ–è®°å½•ã€‚
  - **Dataview**ï¼šç”¨äºæŸ¥è¯¢æ•°æ®å¹¶ç”Ÿæˆå›¾è¡¨ï¼Œæ”¯æŒåŠ¨æ€å¯è§†åŒ–ã€‚
  - **Charts**ï¼šå›¾è¡¨ç»˜åˆ¶ã€‚
  - **Advanced URI**ï¼šå¯é€‰ã€‚

å®‰è£…æ’ä»¶åï¼Œé‡å¯Obsidianä»¥ç¡®ä¿ç”Ÿæ•ˆã€‚

## Part 1: é…ç½®â€œæ™ºèƒ½ç¡çœ æ‰“å¡â€æ¨¡æ¿

é¦–å…ˆï¼Œåœ¨Obsidianè®¾ç½®ä¸­é…ç½®Templaterçš„æ¨¡æ¿æ–‡ä»¶å¤¹ï¼ˆä¾‹å¦‚åˆ›å»ºä¸€ä¸ªåä¸ºâ€œTemplatesâ€çš„æ–‡ä»¶å¤¹ï¼‰ã€‚

### æ™ºèƒ½ç¡çœ è„šæœ¬ (Smart-Sleep.md)

åœ¨ä½ çš„æ¨¡æ¿æ–‡ä»¶å¤¹ä¸‹åˆ›å»º`Smart-Sleep.md`æ–‡ä»¶ï¼Œç²˜è´´ä»¥ä¸‹**å®Œæ•´ä»£ç **ï¼š

<details>
<summary style="color: #4CAF50; font-weight: bold; cursor: pointer;">âš™ï¸ ç‚¹å‡»æŸ¥çœ‹/æŠ˜å â€œæ™ºèƒ½æ¶ˆè´¹å½•å…¥è„šæœ¬â€ä»£ç </summary>

````markdown
```javascript
<%*
// --- âš™ï¸ é…ç½®åŒº ---
const filePath = "è®°å½•/ç¡çœ /ç¡çœ -log.md";
const morningCutoffHour = 5;
const insomniaThresholdHours = 3; // ç¡çœ æ—¶é•¿å°äºç­‰äº 3 å°æ—¶ï¼Œéƒ½å°†è‡ªåŠ¨ä¿®æ­£å…¥ç¡æ—¶é—´
// --- ç»“æŸé…ç½® ---

// --- æ ¸å¿ƒåŠŸèƒ½ ---
const file = tp.file.find_tfile(filePath);
if (!file) {
    new Notice(`âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ–‡ä»¶ "${filePath}"`, 5000);
    return;
}
const content = await app.vault.read(file);
const lines = content.trim().split('\n');
const lastLine = lines[lines.length - 1] || "";

if (lastLine.includes('[bed::') && lastLine.includes('[wake:: ]')) {
    await handleUnfinishedSleep(lastLine, lines.length - 1);
} else {
    await recordBedTime();
}

// --- å‡½æ•°å®šä¹‰ ---

// ã€å·²ä¼˜åŒ–ã€‘å¤„ç†æœªå®Œæˆç¡çœ çš„å‡½æ•°
async function handleUnfinishedSleep(line, lineIndex) {
    const bedMoment = getBedMoment(line);
    if (!bedMoment) return;
    
    const nowMoment = moment();
    const durationSinceBed = moment.duration(nowMoment.diff(bedMoment));

    // ã€æ ¸å¿ƒæ”¹åŠ¨ã€‘ä¸å†å¼¹å‡ºé€‰æ‹©æ¡†ï¼Œç›´æ¥è¿›è¡Œåˆ¤æ–­
    if (durationSinceBed.asHours() <= insomniaThresholdHours) {
        // --- åœºæ™¯ä¸€ï¼šæ—¶é—´å¤ªçŸ­ï¼Œè‡ªåŠ¨åˆ¤å®šä¸ºä¿®æ­£å…¥ç¡æ—¶é—´ ---
        await correctBedTime(line, lineIndex, nowMoment);
    } else {
        // --- åœºæ™¯äºŒï¼šæ—¶é—´è¶³å¤Ÿé•¿ï¼Œè‡ªåŠ¨åˆ¤å®šä¸ºè®°å½•èµ·åºŠ ---
        await recordWakeUp(line, lineIndex, bedMoment, nowMoment);
    }
}

async function recordBedTime() {
    const now = tp.date.now();
    const hour = parseInt(tp.date.now("H"));
    const dateString = (hour < morningCutoffHour) ? tp.date.now("YYYY-MM-DD", -1) : tp.date.now("YYYY-MM-DD");
    const bedTime = tp.date.now("HH:mm");
    const newEntry = `\n- [date:: ${dateString}], [bed:: ${bedTime}], [wake:: ]`;
    
    await app.vault.append(file, newEntry);
    new Notice(`ğŸ›Œ å·²è®°å½•ä¸ŠåºŠæ—¶é—´: ${bedTime}`, 3000);
}

async function recordWakeUp(line, lineIndex, bedMoment, wakeMoment) {
    const duration = moment.duration(wakeMoment.diff(bedMoment));
    const hours = Math.floor(duration.asHours());
    const minutes = duration.minutes();
    
    const wakeTimeFormatted = wakeMoment.format('HH:mm');
    const durationFormatted = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    
    const updatedLine = line.replace('[wake:: ]', `[wake:: ${wakeTimeFormatted}], [duration:: ${durationFormatted}]`);
    
    lines[lineIndex] = updatedLine;
    await app.vault.modify(file, lines.join('\n'));
    new Notice(`èµ·åºŠæˆåŠŸï¼ğŸ‰\n ç¡çœ æ—¶é•¿: ${hours} å°æ—¶ ${minutes} åˆ†é’Ÿ`, 6000);
}

async function correctBedTime(line, lineIndex, newBedMoment) {
    const newBedTime = newBedMoment.format("HH:mm");
    const updatedLine = line.replace(/(\[bed:: )(\d{2}:\d{2})(\])/, `$1${newBedTime}$3`);

    lines[lineIndex] = updatedLine;
    await app.vault.modify(file, lines.join('\n'));
    new Notice(`â° å·²å°†å…¥ç¡æ—¶é—´ä¿®æ­£ä¸º: ${newBedTime}`, 4000);
}

function getBedMoment(line) {
    const match = line.match(/\[date:: (.*?)\].*\[bed:: (.*?)\]/);
    if (!match || !match[1] || !match[2]) {
        new Notice("âŒ é”™è¯¯ï¼šæ— æ³•è§£ææœ€æ–°çš„ç¡çœ è®°å½•ã€‚", 5000);
        return null;
    }
    const dateStr = match[1];
    const bedTimeStr = match[2];
    
    const bedHour = parseInt(bedTimeStr.split(':')[0], 10);
    const bedDateAnchor = moment(dateStr, "YYYY-MM-DD");
    
    if (bedHour < morningCutoffHour) {
        bedDateAnchor.add(1, 'day');
    }
    
    return moment(`${bedDateAnchor.format('YYYY-MM-DD')} ${bedTimeStr}`, "YYYY-MM-DD HH:mm");
}
%>
```
> æç¤ºï¼šæµ‹è¯•å‰ï¼Œå…ˆåœ¨ä½ çš„ä»“åº“æ ¹ç›®å½•åˆ›å»ºä¸€ä¸ªç©ºçš„`ç¡çœ æ—¥è®°-2025.md`æ–‡ä»¶ï¼Œç¡®ä¿è·¯å¾„æ­£ç¡®ã€‚

### æ¨¡æ¿2ï¼šåˆ›å»ºä½ çš„æ—¥å¿—æ–‡ä»¶ (ç¡çœ æ—¥è®°-2025.md)

è¿™ä¸ªæ–‡ä»¶æ—¢æ˜¯ä½ çš„åŸå§‹æ•°æ®å­˜å‚¨åœ°ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå¿«é€Ÿé¢„è§ˆå’Œå¯¼èˆªçš„å…¥å£ã€‚

````markdown
```dataviewjs
// --- é…ç½®åŒº ---
const displayCount = 5; // å®šä¹‰æ˜¾ç¤ºçš„è¡Œæ•°ï¼Œå¯ä»»æ„ä¿®æ”¹ï¼
// --- é…ç½®åŒºç»“æŸ ---

const currentPage = dv.current();
if (currentPage && currentPage.file.lists.length > 0) {
    const recordCount = currentPage.file.lists.length;
    dv.paragraph(`ğŸ›Œ ç¡çœ è®°å½•å…±æœ‰ **${recordCount}** æ¡`);
    
    const clickableHeader = dv.el("h3", "æœ€è¿‘è®°å½• â¬");
    clickableHeader.style.cursor = "pointer"; 
    clickableHeader.onclick = () => {
        let scrollableContainer = dv.container;
        while (scrollableContainer && scrollableContainer.scrollHeight <= scrollableContainer.clientHeight) {
            scrollableContainer = scrollableContainer.parentElement;
        }
        if (scrollableContainer) {
            scrollableContainer.scrollTo({ top: scrollableContainer.scrollHeight, behavior: 'smooth' });
        }
    };
    
    const recentRecords = currentPage.file.lists.slice(-displayCount);
    dv.list(recentRecords.map(item => item.text));
} else {
    dv.paragraph("âŒ æš‚æ— ç¡çœ è®°å½•æ•°æ®ã€‚");
}
```

- [date:: 2025-08-01], [bed:: 23:30], [wake:: 09:50], [duration:: 10:20]ï¼ˆè¿™æ˜¯æ ¼å¼ç¤ºä¾‹ï¼Œä½ ä¸ç”¨æ‰‹åŠ¨è¾“å…¥ï¼‰
````

</details>

> `é‡è¦äº‹é¡¹`ï¼šè¯·ç¡®ä¿ä½ çš„**æ™ºèƒ½ç¡çœ è„šæœ¬**å’Œ**æ•°æ®å¯è§†åŒ–æŠ¥å‘Š**ï¼ˆè§Part 3ï¼‰é¡¶éƒ¨çš„`filePath`è·¯å¾„ï¼Œä¸ä½ è¿™ä¸ªæ—¥å¿—æ–‡ä»¶çš„**çœŸå®è·¯å¾„å’Œæ–‡ä»¶å**å®Œå…¨ä¸€è‡´ï¼è¿™æ˜¯æ•´ä¸ªç³»ç»Ÿèƒ½è¿ä½œèµ·æ¥çš„å…³é”®ã€‚

---
## Part 2: é…ç½®å¿«æ·å‘½ä»¤â€”â€”ä¸€é”®è§¦å‘æ‰€æœ‰æ“ä½œ

è®©è¿™ä¸ªæ™ºèƒ½è„šæœ¬å˜å¾—æ˜“ç”¨ã€‚æˆ‘ä»¬å°†ä¸ºå®ƒç»‘å®šä¸€ä¸ªå‘½ä»¤å’Œå¿«æ·é”®ã€‚

1. **è®¾ç½®Templateræ¨¡æ¿æ–‡ä»¶å¤¹**ï¼š
   - æ‰“å¼€Obsidianè®¾ç½® > ç¤¾åŒºæ’ä»¶ > Templaterã€‚
   - åœ¨â€œTemplate folder locationâ€ä¸­è¾“å…¥ä½ çš„æ¨¡æ¿æ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¦‚â€œTemplates/â€ï¼‰ã€‚

2. **æ·»åŠ å¿«æ·å‘½ä»¤**ï¼š
   - åœ¨Templaterè®¾ç½®ä¸­ï¼Œæ»šåŠ¨åˆ°â€œTemplate Hotkeysâ€ã€‚
   - ç‚¹å‡»â€œAdd newâ€ï¼Œé€‰æ‹©æˆ‘ä»¬åˆ›å»ºçš„`Smart-Sleep.md`æ¨¡æ¿ã€‚
   - **ä¸ºå®ƒåˆ†é…ä¸€ä¸ªä½ å–œæ¬¢çš„å¿«æ·é”®**ï¼ˆå¦‚`âŒ¥+S`ï¼‰ï¼Œå®ç°çœŸæ­£çš„ä¸€é”®æ“ä½œã€‚
   - ç°åœ¨ï¼ŒæŒ‰`âŒ˜+P`æ‰“å¼€å‘½ä»¤é¢æ¿ï¼Œæœç´¢â€œTemplater: Insert Smart-Sleepâ€ï¼Œæˆ–ç›´æ¥æŒ‰ä½ çš„å¿«æ·é”®ï¼Œå³å¯è¿è¡Œè„šæœ¬ã€‚

> æç¤ºï¼šä½ å¯ä»¥å‰å¾€â€œè®¾ç½®â€>â€œå‘½ä»¤é¢æ¿â€ï¼Œä½¿ç”¨ç½®é¡¶åŠŸèƒ½ï¼Œè®©ä½ çš„ç¡çœ å‘½ä»¤æ°¸è¿œå‡ºç°åœ¨æœ€å‰é¢ã€‚

---
## Part 3: æ•°æ®å¯è§†åŒ–â€”â€”ç”¨Dataviewç”Ÿæˆå›¾è¡¨

æœ€åä¸€æ­¥ï¼šè®©æ•°æ®â€œæ´»â€èµ·æ¥ï¼åœ¨ä½ çš„ä¸»é¡µæˆ–ä»»ä½•ç¬”è®°ä¸­æ’å…¥ä»¥ä¸‹DataviewJSä»£ç å—ï¼Œå®ƒä¼šè‡ªåŠ¨ç”Ÿæˆå¤šç§å›¾è¡¨å’Œç»Ÿè®¡ã€‚

<details>
<summary style="color: #4338d5ff; font-weight: bold; cursor: pointer;">ğŸ“Š ç‚¹å‡»æŸ¥çœ‹/æŠ˜å ç¡çœ ç»Ÿè®¡æŠ¥å‘Šä»£ç </summary>

````markdown
```dataviewjs
// ======================================================================
//             Obsidian ç¡çœ ä»ªè¡¨ç›˜ - v1.0 
// ======================================================================
// ä½œè€…: [Seitx's Blog](https://setix.xyz/)
// ç‰ˆæœ¬: 1.0
// æè¿°: ä¸€æ¬¾èƒ½å¤Ÿåº”å¯¹ä»»ä½•çœŸå®ä¸–ç•Œæ•°æ®æ ¼å¼ã€å…·å¤‡æ— æ‡ˆå¯å‡»é€»è¾‘æ ¸å¿ƒçš„æ™ºèƒ½ç¡çœ é¡¾é—®ã€‚
// ======================================================================

const CONFIG = {
    // --- æ ¸å¿ƒé…ç½® ---
    filePath: "6-è®°å½•/ç¡çœ /ç¡çœ log.md", // [å¿…å¡«] ä¿®æ”¹ä¸ºæ‚¨çš„ç¡çœ æ—¥å¿—æ–‡ä»¶è·¯å¾„
    
    diaryPreviewLength: 2000,
    // --- è§†è§‰é…ç½® ---
    colors: {
        bedtime: 'rgb(255, 159, 64)', // æ©™è‰²
        waketime: 'rgb(75, 192, 192)', // é’è‰²
        duration: 'rgb(153, 102, 255)',// ç´«è‰²
    }
};


// --- å·¥å…·å‡½æ•° ---
function formatMoney(number) { return parseFloat(number.toFixed(2)); } // Kept for legacy
function highlightText(text, query) {
    if (!query || typeof text !== 'string') return text;
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(escapedQuery, 'gi');
    return text.replace(regex, (match) => `<span class="search-highlight">${match}</span>`);
}

class SleepSanctuary {
	
    constructor(container, config) {
        this.container = container;
        this.config = config;
        this.app = window.app;
        this.dv = dv;
        this.state = {
            allSleepData: null, monthOffset: 0, yearOffset: 0, activeView: 'monthly',
            activeMetric: 'bedtime', // 'bedtime', 'waketime', or 'recent'
        };
        this.elements = {
            navContainer: null, monthlyContainer: null, annualContainer: null,
            chartContainer: null, listContainer: null, analysisContainer: null,
        };
        this.modalCleanupStack = [];
    }
    
	async init() {
	    this.container.innerHTML = '';
	    try {
	        this.state.allSleepData = await this.parseSleepData();
	        if (this.state.allSleepData === null) {
	            this.renderError("âŒ **é”™è¯¯ï¼š** æ— æ³•åŠ è½½æˆ–è§£æç¡çœ æ—¥å¿—æ–‡ä»¶ã€‚è¯·æ£€æŸ¥ `filePath` é…ç½®æ˜¯å¦æ­£ç¡®ã€‚");
	            return;
	        }
	        this.addGlobalStyles();
	        this.renderLayout();
	        this.switchView(this.state.activeView);
	        this._setupGlobalKeyListener(); 
	    } catch (error) {
	        console.error("ä»ªè¡¨ç›˜åˆå§‹åŒ–å¤±è´¥:", error);
	        this.renderError(`âŒ **è„šæœ¬å‘ç”Ÿä¸¥é‡é”™è¯¯ï¼š** ${error.message}`);
	    }
	}

	_setupGlobalKeyListener() {
	    document.addEventListener('keydown', (event) => {
	        if (event.key === 'Escape' && this.modalCleanupStack.length > 0) {
	            event.preventDefault(); 
	            const cleanupLastModal = this.modalCleanupStack.pop(); 
	            if (cleanupLastModal) {
	                cleanupLastModal();
	            }
	        }
	    });
	}

    _minutesToHM(minutes) {
        const h = Math.floor(minutes / 60);
        const m = Math.round(minutes % 60);
        if (h > 0 && m > 0) return `${h}h${m}m`;
        if (h > 0) return `${h}h`;
        return `${m}m`;
    }

    _averageTime(luxonTimes) {
        if (!luxonTimes || luxonTimes.length === 0) return null;
        const totalMinutes = luxonTimes.reduce((sum, dt) => {
            let minutes = dt.hour * 60 + dt.minute;
            if (dt.hour < 4) minutes += 24 * 60;
            return sum + minutes;
        }, 0);
        
        let avgMinutes = totalMinutes / luxonTimes.length;
        if (avgMinutes >= 24 * 60) avgMinutes -= 24 * 60;
        
        const avgHour = Math.floor(avgMinutes / 60);
        const avgMinute = Math.round(avgMinutes % 60);
        return this.dv.luxon.DateTime.fromObject({ hour: avgHour, minute: avgMinute });
    }

    _calculateGrowth(current, previous, metricType) {
        if (previous === null || current === null) return { text: '--', class: 'neutral' };
        
        let diff = current - previous;
        if (metricType === 'bedtime' || metricType === 'waketime') {
            if (Math.abs(diff) > 12 * 60) {
                diff = diff > 0 ? diff - 24 * 60 : diff + 24 * 60;
            }
        }

        if (Math.abs(diff) < 1) return { text: 'â†’ æ— å˜åŒ–', class: 'neutral' };

        const sign = diff > 0 ? '+' : '-';
        let isPositiveChange;
        switch (metricType) {
            case 'bedtime':
            case 'waketime':
                isPositiveChange = diff < 0;
                break;
            case 'duration':
                isPositiveChange = diff > 0;
                break;
            default:
                isPositiveChange = diff > 0;
        }
        
        const colorClass = isPositiveChange ? 'positive' : 'negative';

        return {
            text: `${sign}${this._minutesToHM(Math.abs(diff))}`,
            class: colorClass
        };
    }
	
    renderError(message) {
        this.container.innerHTML = `<div style="padding: 20px; background-color: var(--background-secondary, #2a2a2a); border-radius: 8px;">${message}</div>`;
    }

    renderLayout() {
        this.elements.navContainer = this.container.createEl('div', { attr: { style: 'display: flex; justify-content: center; margin-bottom: 20px;' } });
        this.createNavButton('å‘¨åº¦èŠ‚å¾‹', 'monthly');
        this.createNavButton('æœˆåº¦è¶‹åŠ¿', 'annual');
        const cardStyleClass = 'content-card';
        this.elements.monthlyContainer = this.container.createEl('div', { cls: cardStyleClass });
        this.elements.annualContainer = this.container.createEl('div', { cls: cardStyleClass });
    }

    createNavButton(text, viewName) {
        const button = this.elements.navContainer.createEl('button', { text: text, attr: { 'data-view': viewName, class: 'main-nav-button' } });
        button.onclick = () => this.switchView(viewName);
    }

    switchView(view) {
        this.state.activeView = view;
        const { monthlyContainer, annualContainer, navContainer } = this.elements;
        monthlyContainer.style.display = view === 'monthly' ? 'block' : 'none';
        annualContainer.style.display = view === 'annual' ? 'block' : 'none';
        navContainer.querySelectorAll('.main-nav-button').forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-view') === view));
        
        if (view === 'monthly') this.renderMonthlyView();
        else if (view === 'annual') this.renderAnnualView();
    }
    
	renderMonthlyView() {
	    const container = this.elements.monthlyContainer;
	    container.innerHTML = '';
	    const targetMonth = this.dv.luxon.DateTime.now().plus({ months: this.state.monthOffset });
	    
	    const nav = container.createEl('div', { attr: { style: 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;' } });
	    const monthSelector = nav.createEl('div', { text: targetMonth.toFormat("yyyyå¹´MMæœˆ"), cls: 'control-button' });
	    monthSelector.onclick = () => this.showMonthPicker(targetMonth);
	    
        const navButton = nav.createEl('button', { cls: 'control-button secondary' });
        if (this.state.monthOffset === 0) {
            navButton.setText('ä¸Šä¸ªæœˆ');
            navButton.onclick = () => { this.state.monthOffset--; this.renderMonthlyView(); };
        } else {
            navButton.setText('è¿”å›æœ¬æœˆ');
            navButton.onclick = () => { this.state.monthOffset = 0; this.renderMonthlyView(); };
        }

	    const sleepData = this.state.allSleepData.filter(t => t.date.hasSame(targetMonth, 'month'));
        const prevMonthData = this.state.allSleepData.filter(t => t.date.hasSame(targetMonth.minus({ months: 1 }), 'month'));
	
	    if (sleepData.length === 0) {
	        container.createEl("p", { text: `âœ… åœ¨ ${targetMonth.toFormat("yyyyå¹´MMæœˆ")} æ²¡æœ‰æ‰¾åˆ°ç¡çœ è®°å½•ã€‚` });
	        return;
	    }
	    
        const avgBedtime = this._averageTime(sleepData.map(s => s.bedTime));
        const avgWaketime = this._averageTime(sleepData.map(s => s.wakeTime));
        const avgDuration = sleepData.reduce((sum, s) => sum + s.durationMinutes, 0) / sleepData.length;
        
        const prevAvgBedtime = this._averageTime(prevMonthData.map(s => s.bedTime));
        const prevAvgWaketime = this._averageTime(prevMonthData.map(s => s.wakeTime));
        const prevAvgDuration = prevMonthData.length > 0 ? prevMonthData.reduce((sum, s) => sum + s.durationMinutes, 0) / prevMonthData.length : null;

	    const summaryContainer = container.createEl('div', { cls: 'summary-container-sleep' });
        const createSummaryItem = (label, value, comparisonData) => {
            const item = summaryContainer.createEl('div');
            item.createEl('div', { text: label, cls: 'summary-label' });
            item.createEl('div', { text: value, cls: 'summary-value' });
            if (comparisonData.prev !== null) {
                const growth = this._calculateGrowth(comparisonData.current, comparisonData.prev, comparisonData.type);
                item.createEl('div', { text: `ç¯æ¯” ${growth.text}`, cls: `growth-indicator ${growth.class}`});
            }
        };

        createSummaryItem("å¹³å‡å…¥ç¡", avgBedtime.toFormat('HH:mm'), { current: avgBedtime.hour * 60 + avgBedtime.minute, prev: prevAvgBedtime ? prevAvgBedtime.hour * 60 + prevAvgBedtime.minute : null, type: 'bedtime' });
        createSummaryItem("å¹³å‡èµ·åºŠ", avgWaketime.toFormat('HH:mm'), { current: avgWaketime.hour * 60 + avgWaketime.minute, prev: prevAvgWaketime ? prevAvgWaketime.hour * 60 + prevAvgWaketime.minute : null, type: 'waketime' });
        createSummaryItem("å¹³å‡æ—¶é•¿", this._minutesToHM(avgDuration), { current: avgDuration, prev: prevAvgDuration, type: 'duration' });

	    this.renderToggleSwitch(container);
	    this.elements.chartContainer = container.createEl('div', { cls: 'chart-wrapper', attr: { style: 'width: 100%; height: 280px; margin: 10px auto;' } });
        this._updateMonthlyChart(targetMonth);

	    container.createEl('hr', { cls: 'divider' });
	    container.createEl('h3', {text: "æœ¬æœˆæ¯æ—¥è®°å½•", cls: 'section-title'});
	    const detailsCard = container.createEl('div', { cls: 'details-card' });
	    this.renderSleepList(detailsCard.createEl('div'), sleepData.sort((a,b) => b.date - a.date));
	}
		
	renderAnnualView() {
	    const container = this.elements.annualContainer;
	    container.innerHTML = '';
	    const targetYear = this.dv.luxon.DateTime.now().plus({ years: this.state.yearOffset });
	
	    const nav = container.createEl('div', { attr: { style: 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;' } });
	    const yearSelector = nav.createEl('div', { text: targetYear.toFormat("yyyyå¹´"), cls: 'control-button' });
	    yearSelector.onclick = () => this.showYearPicker(targetYear);
	
	       const navButton = nav.createEl('button', { cls: 'control-button secondary' });
	       if (this.state.yearOffset === 0) {
	           navButton.setText('ä¸Šä¸€å¹´');
	           navButton.onclick = () => { this.state.yearOffset--; this.renderAnnualView(); };
	       } else {
	           navButton.setText('è¿”å›æœ¬å¹´');
	           navButton.onclick = () => { this.state.yearOffset = 0; this.renderAnnualView(); };
	       }
	       
	    const sleepData = this.state.allSleepData.filter(t => t.date.hasSame(targetYear, 'year'));
	    if (sleepData.length === 0) {
	        container.createEl("p", { text: `âœ… åœ¨ ${targetYear.toFormat("yyyy'å¹´'")} æ²¡æœ‰æ‰¾åˆ°ç¡çœ è®°å½•ã€‚` });
	        return;
	    }
	    
	       const prevYearData = this.state.allSleepData.filter(t => t.date.hasSame(targetYear.minus({years: 1}), 'year'));
	       const avgBedtime = this._averageTime(sleepData.map(s => s.bedTime));
	       const avgWaketime = this._averageTime(sleepData.map(s => s.wakeTime));
	       const avgDuration = sleepData.reduce((sum, s) => sum + s.durationMinutes, 0) / sleepData.length;
	       
	       const prevAvgBedtime = this._averageTime(prevYearData.map(s => s.bedTime));
	       const prevAvgWaketime = this._averageTime(prevYearData.map(s => s.wakeTime));
	       const prevAvgDuration = prevYearData.length > 0 ? prevYearData.reduce((sum, s) => sum + s.durationMinutes, 0) / prevYearData.length : null;
	
	       const summaryContainer = container.createEl('div', { cls: 'summary-container-sleep' });
	       const createSummaryItem = (label, value, comparisonData) => {
	           const item = summaryContainer.createEl('div');
	           item.createEl('div', { text: label, cls: 'summary-label' });
	           item.createEl('div', { text: value, cls: 'summary-value' });
	           if (comparisonData.prev !== null) {
	               const growth = this._calculateGrowth(comparisonData.current, comparisonData.prev, comparisonData.type);
	               item.createEl('div', { text: `åŒæ¯” ${growth.text}`, cls: `growth-indicator ${growth.class}`});
	           }
	       };
	
	       createSummaryItem("å¹³å‡å…¥ç¡", avgBedtime.toFormat('HH:mm'), { current: avgBedtime.hour * 60 + avgBedtime.minute, prev: prevAvgBedtime ? prevAvgBedtime.hour * 60 + prevAvgBedtime.minute : null, type: 'bedtime' });
	       createSummaryItem("å¹³å‡èµ·åºŠ", avgWaketime.toFormat('HH:mm'), { current: avgWaketime.hour * 60 + avgWaketime.minute, prev: prevAvgWaketime ? prevAvgWaketime.hour * 60 + prevAvgWaketime.minute : null, type: 'waketime' });
	       createSummaryItem("å¹³å‡æ—¶é•¿", this._minutesToHM(avgDuration), { current: avgDuration, prev: prevAvgDuration, type: 'duration' });
	    
	    this.renderToggleSwitch(container);
	
	       const monthlyBedtimes = Array.from({ length: 12 }, () => []);
	       const monthlyWaketimes = Array.from({ length: 12 }, () => []);
	       const monthlyDurations = Array.from({ length: 12 }, () => []);
	       sleepData.forEach(s => {
	           monthlyBedtimes[s.date.month - 1].push(s.bedTime);
	           monthlyWaketimes[s.date.month - 1].push(s.wakeTime);
	           monthlyDurations[s.date.month - 1].push(s.durationMinutes);
	       });
	
	       const monthlyAvgBedtimes = monthlyBedtimes.map(month => this._averageTime(month));
	       const monthlyAvgWaketimes = monthlyWaketimes.map(month => this._averageTime(month));
	       const monthlyAvgDurations = monthlyDurations.map(month => month.length > 0 ? month.reduce((a,b)=>a+b,0) / month.length : null);
	
	    this.elements.chartContainer = container.createEl('div', { cls: 'chart-wrapper', attr: { style: 'width: 100%; height: 280px; margin: 10px auto;' } });
	    this._updateAnnualChart(monthlyAvgBedtimes, monthlyAvgWaketimes, monthlyAvgDurations);
	       
	       container.createEl('hr', { cls: 'divider' });
	       container.createEl('h3', { text: 'æ‚¨çš„å¹´åº¦ç¡çœ æ•…äº‹æ¿', cls: 'section-title analysis-section-title' });
	       this.renderSleepStoryboard(container.createEl('div'), sleepData);
	}

    renderSleepStoryboard(container, sleepData) {
        if(sleepData.length < 7) {
            container.createEl('p', { text: 'å¹´åº¦ç¡çœ è®°å½•è¿‡å°‘ï¼Œæ— æ³•ç”Ÿæˆæ•…äº‹æ¿ã€‚', attr: {style: 'text-align: center; color: var(--text-muted);'} });
            return;
        }

        const grid = container.createEl('div', { cls: 'analysis-grid' });

        const monthlyBedtimes = Array.from({length: 12}, () => []);
        sleepData.forEach(s => monthlyBedtimes[s.date.month - 1].push(s.bedTime));
        const monthlyAvgBedtimes = monthlyBedtimes.map(m => this._averageTime(m));
        
        let latestMonthIndex = -1, latestBedtime = -1;
        monthlyAvgBedtimes.forEach((bt, i) => {
            if(bt) {
                let minutes = bt.hour * 60 + bt.minute;
                if (bt.hour < 4) minutes += 24 * 60;
                if(minutes > latestBedtime) {
                    latestBedtime = minutes;
                    latestMonthIndex = i;
                }
            }
        });

        if (latestMonthIndex > -1) {
            const card1 = grid.createEl('div', { cls: 'analysis-card' });
            card1.createEl('h4', {text: 'ğŸŒ™ ç†¬å¤œå† å†›æœˆ'});
            const monthName = this.dv.luxon.DateTime.fromObject({month: latestMonthIndex + 1}).toFormat('MMMM');
            card1.createEl('p').innerHTML = `æ‚¨çš„ç¡çœ åœ¨ <b>${monthName}</b> æœ€ä¸ºæ”¾çºµï¼Œå¹³å‡å…¥ç¡æ—¶é—´è¾¾åˆ°äº† <b>${monthlyAvgBedtimes[latestMonthIndex].toFormat('HH:mm')}</b>ã€‚`;
            card1.createEl('p', {cls: 'analysis-insight', text: 'æ˜¯é¡¹ç›®å†²åˆºï¼Œè¿˜æ˜¯æ²‰è¿·å¤œç”Ÿæ´»ï¼Ÿè¿™ä¸ªæœˆå€¼å¾—æ‚¨ç‰¹åˆ«å›é¡¾ã€‚'});
        }

        const weekdaySleep = [];
        const weekendSleep = [];
        sleepData.forEach(s => {
            if (s.date.weekday >= 1 && s.date.weekday <= 5) weekdaySleep.push(s.durationMinutes);
            else weekendSleep.push(s.durationMinutes);
        });

        if (weekdaySleep.length > 0 && weekendSleep.length > 0) {
            const avgWeekday = weekdaySleep.reduce((a,b)=>a+b,0) / weekdaySleep.length;
            const avgWeekend = weekendSleep.reduce((a,b)=>a+b,0) / weekendSleep.length;
            const debt = avgWeekend - avgWeekday;

            const card2 = grid.createEl('div', { cls: 'analysis-card' });
            card2.createEl('h4', {text: ' debt ç¡çœ è´Ÿå€º'});
            card2.createEl('p').innerHTML = `æ‚¨å¹³å‡åœ¨å‘¨æœ«æ¯”å·¥ä½œæ—¥å¤šç¡ <b>${this._minutesToHM(Math.abs(debt))}</b>ã€‚`;
            const insightText = debt > 0 
                ? 'è¿™è¯´æ˜æ‚¨å¯èƒ½åœ¨ç”¨å‘¨æœ«â€œè¡¥å¿â€å·¥ä½œæ—¥çš„ç¡çœ ä¸è¶³ã€‚'
                : 'æ­å–œï¼æ‚¨çš„ä½œæ¯éå¸¸è§„å¾‹ï¼Œç”šè‡³å‘¨æœ«ç¡å¾—æ›´å°‘ã€‚';
            card2.createEl('p', {cls: 'analysis-insight', text: insightText});
        }
    }
	
	renderToggleSwitch(container) {
	    const switchContainer = container.createEl('div', { attr: { class: 'toggle-switch-container-sleep' } });
        const recentOption = switchContainer.createEl('div', {text: 'è¿‘æœŸç¡çœ ', cls: 'toggle-switch-option-sleep'});
	    const bedtimeOption = switchContainer.createEl('div', { text: 'å…¥ç¡æ—¶é—´', cls: 'toggle-switch-option-sleep' });
	    const waketimeOption = switchContainer.createEl('div', { text: 'èµ·åºŠæ—¶é—´', cls: 'toggle-switch-option-sleep' });
	    
        const setActiveState = (metric) => {
            recentOption.classList.toggle('active', metric === 'recent');
            bedtimeOption.classList.toggle('active', metric === 'bedtime');
            waketimeOption.classList.toggle('active', metric === 'waketime');
	    };
	    
        setActiveState(this.state.activeMetric);

        const updateChart = () => {
            if (this.state.activeView === 'monthly') {
                const targetMonth = this.dv.luxon.DateTime.now().plus({ months: this.state.monthOffset });
                this._updateMonthlyChart(targetMonth);
            } else {
                this.renderAnnualView();
            }
        };
	    
        recentOption.onclick = () => {
            if (this.state.activeMetric !== 'recent') {
                this.state.activeMetric = 'recent';
                setActiveState('recent');
                updateChart();
            }
        };
	    bedtimeOption.onclick = () => {
	        if (this.state.activeMetric !== 'bedtime') {
                this.state.activeMetric = 'bedtime';
                setActiveState('bedtime');
                updateChart();
            }
	    };
	    waketimeOption.onclick = () => {
	        if (this.state.activeMetric !== 'waketime') {
                this.state.activeMetric = 'waketime';
                setActiveState('waketime');
                updateChart();
            }
	    };
	}
	
    _createOverlay(className = 'picker-container') {
        const overlay = document.body.createEl('div', { cls: 'picker-overlay' });
        const container = overlay.createEl('div', { cls: className });
        const close = () => { overlay.classList.remove('visible'); setTimeout(() => overlay.remove(), 200); };
        setTimeout(() => overlay.classList.add('visible'), 10);
        return { overlay, container, close };
    }

	showMonthPicker(currentDate) {
        let pickerYear = currentDate.year;
        const update = (title, grid, closeFn) => {
            title.textContent = `${pickerYear}å¹´`; grid.className = 'picker-grid'; grid.innerHTML = '';
            for (let i = 1; i <= 12; i++) {
                const item = grid.createEl('div', { text: `${i}æœˆ`, cls: 'picker-grid-item' });
                if (pickerYear === currentDate.year && i === currentDate.month) item.classList.add('selected');
                item.onclick = () => { const now = this.dv.luxon.DateTime.now(); this.state.monthOffset = (pickerYear - now.year) * 12 + (i - now.month); this.renderMonthlyView(); closeFn(); };
            }
        };
        const { container, close, overlay } = this._createOverlay();
        const header = container.createEl('div', { cls: 'picker-header' });
        const prevBtn = header.createEl('button', { text: 'â€¹' }); const title = header.createEl('div', { cls: 'picker-title' }); const nextBtn = header.createEl('button', { text: 'â€º' });
        const grid = container.createEl('div');
        prevBtn.onclick = () => { pickerYear--; update(title, grid, close); }; nextBtn.onclick = () => { pickerYear++; update(title, grid, close); };
        update(title, grid, close);
        
        const cleanupAndClose = () => {
            if (this.modalCleanupStack[this.modalCleanupStack.length - 1] === cleanupAndClose) { this.modalCleanupStack.pop(); }
            close();
        };

        overlay.onclick = (e) => { if (e.target === overlay) { cleanupAndClose(); } };
        this.modalCleanupStack.push(cleanupAndClose);
    }

    showYearPicker(currentDate) {
        let centralYear = currentDate.year;
        const update = (title, grid, closeFn) => {
            const startYear = centralYear - 5; title.textContent = `${startYear} - ${startYear + 6}`;
            grid.className = 'picker-grid year-grid'; grid.innerHTML = '';
            for (let i = 0; i < 12; i++) {
                const year = startYear + i; const item = grid.createEl('div', { text: year, cls: 'picker-grid-item' });
                if (year === currentDate.year) item.classList.add('selected');
                item.onclick = () => { this.state.yearOffset = year - this.dv.luxon.DateTime.now().year; this.renderAnnualView(); closeFn(); };
            }
        };
        const { container, close, overlay } = this._createOverlay();
        const header = container.createEl('div', { cls: 'picker-header' });
        const prevBtn = header.createEl('button', { text: 'â€¹' }); const title = header.createEl('div', { cls: 'picker-title' }); const nextBtn = header.createEl('button', { text: 'â€º' });
        const grid = container.createEl('div');
        prevBtn.onclick = () => { centralYear -= 12; update(title, grid, close); }; nextBtn.onclick = () => { centralYear += 12; update(title, grid, close); };
        update(title, grid, close);

        const cleanupAndClose = () => {
            if (this.modalCleanupStack[this.modalCleanupStack.length - 1] === cleanupAndClose) { this.modalCleanupStack.pop(); }
            close();
        };

        overlay.onclick = (e) => { if (e.target === overlay) { cleanupAndClose(); } };
        this.modalCleanupStack.push(cleanupAndClose);
    }

	async showFilePreviewModal(files) {
	    const { container, close, overlay } = this._createOverlay('file-preview-modal');
	    
	    const contentEl = container.createEl('div', { cls: 'file-preview-content' });
	    
	    for(const file of files) {
	        const content = await this.app.vault.cachedRead(file);
	        let previewText = content.replace(/---[\s\S]*?---/, '').trim();
	        
	        // [æ¶æ„å‡å] ä½¿ç”¨ this.config.diaryPreviewLength æ›¿ä»£ç¡¬ç¼–ç çš„ "100"
	        const previewLength = this.config.diaryPreviewLength;
	        previewText = previewText.substring(0, previewLength).replace(/\n/g, ' ') + (previewText.length > previewLength ? '...' : '');
	
	        const fileItem = contentEl.createEl('div', { cls: 'file-preview-item' });
	        fileItem.createEl('div', { text: file.path, cls: 'file-preview-path' });
	        fileItem.createEl('p', { text: previewText, cls: 'file-preview-summary' });
	        
	        fileItem.onclick = () => {
	            this.app.workspace.getLeaf(false).openFile(file);
	            cleanupAndClose();
	        };
	    }
	
	    const cleanupAndClose = () => {
	        if (this.modalCleanupStack[this.modalCleanupStack.length - 1] === cleanupAndClose) { this.modalCleanupStack.pop(); }
	        close();
	    };
	
	    overlay.onclick = (e) => { if (e.target === overlay) { cleanupAndClose(); } };
	    this.modalCleanupStack.push(cleanupAndClose);
	}

	renderSleepList(container, sleepData) {
       container.innerHTML = '';
       if (sleepData.length === 0) { container.innerHTML = '<p style="text-align:center; color: var(--text-muted); padding: 20px 0;">æ— è®°å½•</p>'; return; }
       sleepData.forEach(item => {
           const itemEl = container.createEl('div', { cls: 'transaction-item-container', attr: { 'data-date': item.date.toFormat('yy-MM-dd') } });
           itemEl.style.cursor = 'pointer';
           itemEl.onclick = async () => {
               const targetDate = item.date;
               const dateStr = targetDate.toFormat('yy-MM-dd');
               
               // ç­–ç•¥ä¸€ï¼šæ–‡ä»¶ååŒ¹é…
               const filesByName = this.app.vault.getMarkdownFiles().filter(f => f.name.includes(dateStr));
               
               // ç­–ç•¥äºŒï¼šåˆ›å»ºæ—¥æœŸåŒ¹é…
               const filesByCreationDate = this.app.vault.getMarkdownFiles().filter(f => {
                   const fileDate = this.dv.luxon.DateTime.fromMillis(f.stat.ctime);
                   return fileDate.hasSame(targetDate, 'day');
               });
               
               // [å…³é”®] æ•°æ®èåˆä¸å»é‡åè®®
               const combinedFiles = [...filesByName, ...filesByCreationDate];
               const uniqueFiles = Array.from(new Set(combinedFiles.map(f => f.path)))
                                      .map(path => combinedFiles.find(f => f.path === path));

               if (uniqueFiles.length >= 1) {
                   this.showFilePreviewModal(uniqueFiles);
               }
           };

           const firstLine = itemEl.createEl('div', { attr: { style: 'display: flex; justify-content: space-between; align-items: center;' } });
           firstLine.createEl('span', { text: item.date.toFormat("yyyyå¹´Mæœˆdæ—¥, cccc"), attr: { style: 'font-size: 0.95em; font-weight: 500;'}});
           firstLine.createEl('span', { text: this._minutesToHM(item.durationMinutes), attr: { style: 'font-size: 0.95em; font-family: monospace; color: var(--text-accent);'}});
           const secondLine = itemEl.createEl('div', { attr: { style: 'display: flex; justify-content: space-between; align-items: baseline; margin-top: 2px;' } });
           secondLine.createEl('span', { text: `${item.bedTime.toFormat('HH:mm')}-${item.wakeTime.toFormat('HH:mm')}`, attr: {style: 'font-size: 0.85em; color: var(--text-muted);'}});
       });
   }

    showFilePickerModal(files) {
        const { container, close, overlay } = this._createOverlay('file-picker-modal');
        container.createEl('h3', { text: 'é€‰æ‹©è¦æ‰“å¼€çš„æ–‡ä»¶' });
        const listEl = container.createEl('ul', { cls: 'file-picker-list' });
        files.forEach(file => {
            const li = listEl.createEl('li');
            li.setText(file.path);
            li.onclick = () => {
                this.app.workspace.getLeaf(false).openFile(file);
                close();
            };
        });

        const cleanupAndClose = () => {
            if (this.modalCleanupStack[this.modalCleanupStack.length - 1] === cleanupAndClose) { this.modalCleanupStack.pop(); }
            close();
        };

        overlay.onclick = (e) => { if (e.target === overlay) { cleanupAndClose(); } };
        this.modalCleanupStack.push(cleanupAndClose);
    }

    _updateMonthlyChart(targetMonth) {
        this.elements.chartContainer.innerHTML = '';
        const chartId = `chart-${Date.now()}`;
        this.elements.chartContainer.createEl('div', { attr: { id: chartId, style: 'width: 100%; height: 100%;' }});

        const sleepData = this.state.allSleepData.filter(t => t.date.hasSame(targetMonth, 'month'));

        if (this.state.activeMetric === 'recent') {
            const recentSleep = this.state.allSleepData.sort((a,b) => b.date - a.date).slice(0, 7).reverse();
            this.renderSleepChart(chartId, null, null, false, recentSleep);
        } else {
            const weeksInMonth = Math.ceil(targetMonth.endOf('month').day / 7);
            const weeklyBedtimes = Array.from({ length: weeksInMonth }, () => []);
            const weeklyWaketimes = Array.from({ length: weeksInMonth }, () => []);
            sleepData.forEach(s => {
                const weekIndex = Math.floor((s.date.day - 1) / 7);
                if(weeklyBedtimes[weekIndex]) {
                    weeklyBedtimes[weekIndex].push(s.bedTime);
                    weeklyWaketimes[weekIndex].push(s.wakeTime);
                }
            });
            const weeklyAvgBedtimes = weeklyBedtimes.map(week => this._averageTime(week));
            const weeklyAvgWaketimes = weeklyWaketimes.map(week => this._averageTime(week));
            this.renderSleepChart(chartId, weeklyAvgBedtimes, weeklyAvgWaketimes, false);
        }
    }
    
	_updateAnnualChart(monthlyAvgBedtimes, monthlyAvgWaketimes, monthlyAvgDurations){
	    this.elements.chartContainer.innerHTML = '';
	    const chartId = `chart-${Date.now()}`;
	    this.elements.chartContainer.createEl('div', { attr: { id: chartId, style: 'width: 100%; height: 100%;' }});
	    this.renderSleepChart(chartId, monthlyAvgBedtimes, monthlyAvgWaketimes, true, null, monthlyAvgDurations);
	}
    
	renderSleepChart(containerId, bedtimes, waketimes, isAnnual = false, recentData = null, durationData = null) {
	    setTimeout(() => {
	        const el = document.getElementById(containerId);
	        if (!el) return;
	        if (typeof renderChart === 'undefined') {
	            el.innerHTML = `<div style="text-align:center; padding: 20px; color: var(--text-muted);">âš ï¸ **è­¦å‘Šï¼š** æœªå®‰è£…æˆ–å¯ç”¨ <code>Obsidian Charts</code> æ’ä»¶ï¼Œæ— æ³•æ¸²æŸ“å›¾è¡¨ã€‚</div>`;
	            return;
	        }
	        let chartConfig;
	        const createGradient = (ctx, chartArea, color) => { if (!chartArea) return null; const g = ctx.createLinearGradient(0, chartArea.top, 0, chartArea.bottom); g.addColorStop(0, color.replace(')', ', 0.4)').replace('rgb', 'rgba')); g.addColorStop(1, color.replace(')', ', 0)').replace('rgb', 'rgba')); return g; };
	
	        if (this.state.activeMetric === 'recent') {
	            const label = isAnnual ? 'æœˆå¹³å‡ç¡çœ æ—¶é•¿' : 'è¿‘æœŸç¡çœ æ—¶é•¿';
	            const dataPoints = isAnnual ? durationData : recentData.map(s => s.durationMinutes);
	            
	            chartConfig = {
	                type: 'line',
	                data: {
	                    labels: isAnnual ? ['1æœˆ','2æœˆ','3æœˆ','4æœˆ','5æœˆ','6æœˆ','7æœˆ','8æœˆ','9æœˆ','10æœˆ','11æœˆ','12æœˆ'] : recentData.map(s => s.date.toFormat('MM-dd')),
	                    datasets: [{
	                        label: label,
	                        data: dataPoints,
	                        borderColor: this.config.colors.duration,
	                        backgroundColor: c => createGradient(c.chart.ctx, c.chart.chartArea, this.config.colors.duration),
	                        fill: true,
	                        tension: 0.4
	                    }]
	                },
	                options: {
	                    responsive: true, maintainAspectRatio: false,
	                    interaction: { intersect: false, mode: 'index' },
	                    scales: { y: { ticks: { callback: val => this._minutesToHM(val) } } },
	                    plugins: { 
	                        legend: { display: true, labels:{ usePointStyle:true, boxWidth:8 } }, 
	                        tooltip: { callbacks: { label: ctx => ` ${ctx.dataset.label}: ${this._minutesToHM(ctx.parsed.y)}` } } 
	                    }
	                }
	            };
	        } else {
	            const activeData = this.state.activeMetric === 'bedtime' ? bedtimes : waketimes;
	            const label = this.state.activeMetric === 'bedtime' ? 'å¹³å‡å…¥ç¡æ—¶é—´' : 'å¹³å‡èµ·åºŠæ—¶é—´';
	            const color = this.state.activeMetric === 'bedtime' ? this.config.colors.bedtime : this.config.colors.waketime;
	
	            const chartDataPoints = activeData.map(dt => dt ? (dt.hour * 60 + dt.minute + (dt.hour < 4 ? 24*60 : 0)) : null);
	            const validMinutes = chartDataPoints.filter(m => m !== null);
	            if(validMinutes.length === 0) return;
	
	            const minTime = Math.min(...validMinutes);
	            const maxTime = Math.max(...validMinutes);
	            const buffer = 30;
	            const yMin = Math.max(0, minTime - buffer);
	            const yMax = maxTime + buffer;
	            
	            chartConfig = { 
	                type:'line', 
	                data:{ 
	                    labels: isAnnual ? ['1æœˆ','2æœˆ','3æœˆ','4æœˆ','5æœˆ','6æœˆ','7æœˆ','8æœˆ','9æœˆ','10æœˆ','11æœˆ','12æœˆ'] : bedtimes.map((_,i) => `ç¬¬${i+1}å‘¨`),
	                    datasets:[{
	                        label: label, data: chartDataPoints, borderColor: color,
	                        backgroundColor: c => createGradient(c.chart.ctx,c.chart.chartArea,color),
	                        fill:true, tension:0.4
	                    }] 
	                }, 
	                options:{ 
	                    responsive:true, maintainAspectRatio:false,
	                    interaction: { intersect: false, mode: 'index' },
	                    scales:{
	                        y: {
	                            min: yMin, max: yMax,
	                            ticks: {
	                                stepSize: 12,
	                                callback: (v) => { let h = Math.floor(v/60)%24, m = v%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
	                            }
	                        }
	                    },
	                    plugins:{
	                        legend:{ display: true, labels: { usePointStyle: true, boxWidth: 8 } },
	                        tooltip: {
	                            callbacks: {
	                                label: (c) => { const v = c.parsed.y, h = Math.floor(v/60)%24, m=v%60; return ` ${c.dataset.label}: ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
	                            }
	                        }
	                    }
	                }
	            };
	        }
	        try { renderChart(chartConfig, el); } catch (e) { el.setText(`âŒ å›¾è¡¨æ¸²æŸ“å¤±è´¥: ${e.message}`); }
	    }, 50);
	}

    async parseSleepData() {
        const file = this.app.vault.getAbstractFileByPath(this.config.filePath); if (!file) return null;
        const content = await this.app.vault.read(file);
        const lines = content.split('\n');
        const sleepData = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim(); 
            if (!line.startsWith('- ')) continue;

            const dateMatch = line.match(/\[date:: (.*?)\]/);
            const bedMatch = line.match(/\[bed:: (.*?)\]/);
            const wakeMatch = line.match(/\[wake:: (.*?)\]/);

            if (dateMatch && bedMatch && wakeMatch) {
                try {
                    const date = this.dv.luxon.DateTime.fromISO(dateMatch[1].trim());
                    const bedTimeStr = bedMatch[1].trim();
                    const wakeTimeStr = wakeMatch[1].trim();

                    const [bedH, bedM] = bedTimeStr.split(':').map(Number);
                    const [wakeH, wakeM] = wakeTimeStr.split(':').map(Number);
                    
                    let bedDateTime = date.set({ hour: bedH, minute: bedM });
                    let wakeDateTime = date.set({ hour: wakeH, minute: wakeM });

                    if (wakeDateTime < bedDateTime) {
                        wakeDateTime = wakeDateTime.plus({ days: 1 });
                    }

                    const duration = wakeDateTime.diff(bedDateTime, 'minutes');
                    const durationMinutes = duration.as('minutes');

                    sleepData.push({ 
                        date: date, 
                        bedTime: bedDateTime, 
                        wakeTime: wakeDateTime, 
                        durationMinutes: durationMinutes, 
                        lineNumber: i, 
                        raw: line 
                    });

                } catch(e) {
                    console.warn(`[ç¡çœ åœ£æ®¿] ç¬¬ ${i+1}è¡Œ è§£æå¤±è´¥: "${line}"`, e);
                }
            }
        }
        return sleepData;
    }

	addGlobalStyles() {
	    const styleId = 'sleep-sanctuary-global-style-v3.1.0';
	    document.querySelectorAll('[id^="sleep-sanctuary-global-style"]').forEach(el => el.remove());
	    if (document.getElementById(styleId)) return;
	
	    const style = document.createElement('style');
	    style.id = styleId;
	    style.innerHTML = `
	        .content-card { background-color: var(--background-secondary, #2a2a2a); border-radius: 12px; padding: 25px; border: 1px solid var(--background-modifier-border, #444); }
	        .divider { border: none; border-top: 1px solid var(--background-modifier-border, #444); margin: 30px 0 20px; }
	        .section-title { margin-bottom: 15px; font-size: 1.1em; font-weight: 600; }
	        .main-nav-button { background-color: var(--background-secondary-alt, #3a3a3a); border: 1px solid var(--background-modifier-border, #444); border-radius: 8px; padding: 8px 14px; font-size: 0.9em; cursor: pointer; flex-grow: 1; text-align: center; font-weight: 500; transition: all 0.2s ease; }
	        .main-nav-button:hover { background-color: var(--background-modifier-hover, #4a4a4a); }
	        .main-nav-button.active { background-color: var(--interactive-accent, #4e6f9a) !important; color: var(--text-on-accent, white) !important; border-color: var(--interactive-accent-hover, #587db3); }
	        .control-button { padding: 7px 16px; font-size: 0.9em; font-weight: 500; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; background-color: var(--background-secondary-alt, #3a3a3a); color: var(--text-normal, #ddd); border: 1px solid var(--background-modifier-border, #444); }
	        .control-button:hover { background-color: var(--background-modifier-hover, #4a4a4a); border-color: var(--background-modifier-border-hover, #555); }
	        .control-button.secondary { background-color: transparent; color: var(--text-muted, #999); border-color: transparent; }
	        .control-button.secondary:hover { background-color: var(--background-secondary-alt, #3a3a3a); color: var(--text-normal, #ddd); }
            .summary-container-sleep { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center; margin-bottom: 25px; padding: 12px 0; background-color: var(--background-secondary-alt, #3a3a3a); border-radius: 8px; }
	        .summary-label { font-size: 0.85em; color: var(--text-muted, #999); margin-bottom: 4px; }
	        .summary-value { font-size: 1.35em; font-weight: 600; font-family: monospace; color: var(--text-normal, #ddd); }
            .growth-indicator { font-size: 0.8em; margin-top: 4px; font-weight: 500; }
            .growth-indicator.positive { color: var(--color-green); }
            .growth-indicator.negative { color: var(--color-red); }
            .growth-indicator.neutral { color: var(--text-faint); }
	        .details-card { background-color: var(--background-secondary-alt, #3a3a3a); border-radius: 8px; padding: 5px 15px; }
	        .transaction-item-container { border-top: 1px solid var(--background-modifier-border, #444); padding: 8px 4px; }
	        .details-card > div > .transaction-item-container:first-child { border-top: none; }
	        .picker-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease; }
	        .picker-overlay.visible { opacity: 1; }
	        .picker-container { background-color: var(--background-secondary, #2a2a2a); border: 1px solid var(--background-modifier-border, #444); border-radius: 12px; padding: 15px 20px 25px; width: 90%; max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transform: scale(0.9); transition: transform 0.2s ease; }
	        .picker-overlay.visible .picker-container { transform: scale(1); }
	        .picker-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
	        .picker-header button { font-size: 1.2em; background: none; border: none; cursor: pointer; color: var(--text-normal, #ddd); }
	        .picker-title { font-size: 1.2em; font-weight: bold; text-align: center; }
	        .picker-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
	        .picker-grid.year-grid { grid-template-columns: repeat(4, 1fr); }
	        .picker-grid-item { padding: 12px; text-align: center; border-radius: 8px; background-color: var(--background-secondary-alt, #3a3a3a); cursor: pointer; transition: background-color 0.2s; }
	        .picker-grid-item:hover { background-color: var(--background-modifier-hover, #4a4a4a); }
	        .picker-grid-item.selected { background-color: var(--interactive-accent, #4e6f9a); color: var(--text-on-accent, white); font-weight: bold; }
	        .analysis-section-title { text-align: center; font-size: 1.5em; margin-top: 20px; margin-bottom: 25px; }
	        .analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; }
	        .analysis-card { background-color: var(--background-secondary-alt); border-radius: 10px; padding: 20px; border: 1px solid var(--background-modifier-border); display: flex; flex-direction: column; gap: 10px; }
	        .analysis-card h4 { margin: 0 0 5px 0; font-size: 1.1em; font-weight: 600; }
	        .analysis-card ul { padding-inline-start: 20px; margin: 0; flex-grow: 1; }
	        .analysis-card li { margin-bottom: 5px; }
            .analysis-card b { font-weight: 600; color: inherit; }
	        .analysis-insight { font-size: 0.85em; color: var(--text-muted); margin-top: auto; padding-top: 10px; border-top: 1px solid var(--background-modifier-border); }
            .toggle-switch-container-sleep { display: flex; justify-content: center; margin: 20px 0; background-color: var(--background-secondary); padding: 5px; border-radius: 25px; width: fit-content; margin-left: auto; margin-right: auto; }
            .toggle-switch-option-sleep { padding: 8px 20px; font-size: 0.9em; font-weight: 500; cursor: pointer; color: var(--text-muted); border-radius: 20px; transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
            .toggle-switch-option-sleep.active { color: var(--text-normal); background-color: var(--background-modifier-hover); }
            .file-picker-list { list-style: none; padding: 0; max-height: 200px; overflow-y: auto; }
            .file-picker-list li { padding: 10px; border-radius: 6px; cursor: pointer; }
            .file-picker-list li:hover { background-color: var(--background-modifier-hover); }
			.file-preview-modal {
			    background-color: var(--background-secondary);
			    border: 1px solid var(--background-modifier-border);
			    border-radius: 12px;
			    padding: 0;
			    width: 90%;
			    max-width: 600px;
			    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
			}
			.file-preview-content {
			    max-height: 400px;
			    overflow-y: auto;
			    padding: 10px;
			}
			.file-preview-item {
			    padding: 12px 15px;
			    border-radius: 8px;
			    cursor: pointer;
			    transition: background-color 0.2s ease;
			    border-bottom: 1px solid var(--background-modifier-border);
			}
			.file-preview-item:last-child {
			    border-bottom: none;
			}
			.file-preview-item:hover {
			    background-color: var(--background-modifier-hover);
			}
			.file-preview-path {
			    font-weight: 500;
			    font-size: 0.9em;
			    color: var(--text-normal);
			}
			.file-preview-summary {
			    font-size: 0.8em;
			    color: var(--text-muted);
			    margin-top: 5px;
			    
			    /* [æ ¸å¿ƒä¿®å¤] å…è®¸å¤šè¡Œæ–‡æœ¬æˆªæ–­ */
			    overflow: hidden;
			    display: -webkit-box;
			    -webkit-box-orient: vertical;
			    -webkit-line-clamp: 3; /* æ‚¨å¯ä»¥åœ¨è¿™é‡Œè°ƒæ•´é»˜è®¤æ˜¾ç¤º3è¡Œï¼Œå¦‚æœéœ€è¦æ›´å¤šï¼Œå¯ä»¥å¢å¤§æ­¤æ•°å­— */
			    line-height: 1.5; /* ç¡®ä¿è¡Œé—´è·èˆ’é€‚ */
			}
	    `;
	    document.head.appendChild(style);
	}
	
}

try {
    const dashboard = new SleepSanctuary(dv.container, CONFIG);
    dashboard.init();
} catch (e) {
    dv.container.setText("âŒ Dataview è„šæœ¬æ‰§è¡Œå¤±è´¥: " + e.message);
}
```
````

</details>

> æç¤ºï¼šä»£ç ä¼šä»CDNåŠ è½½Chart.jsï¼Œç¡®ä¿ä½ çš„Obsidianæœ‰ç½‘ç»œæƒé™ã€‚å¦‚æœå›¾è¡¨ä¸æ˜¾ç¤ºï¼Œæ£€æŸ¥æ–‡ä»¶è·¯å¾„å’Œæ•°æ®æ ¼å¼ã€‚

## ç»“è¯­

æ­å–œï¼ä½ ç°åœ¨æ‹¥æœ‰äº†ä¸€å¥—å®Œæ•´çš„Obsidianç¡çœ è‡ªåŠ¨åŒ–ç³»ç»Ÿã€‚ä»æ‰‹åŠ¨è®°å½•çš„çƒ¦æ¼ï¼Œåˆ°ä¸€é”®æ“ä½œå’Œæ™ºèƒ½å›¾è¡¨çš„ä¾¿åˆ©ï¼Œè¿™ä¸ä»…ä»…æ˜¯å·¥å…·ï¼Œæ›´æ˜¯ç”Ÿæ´»ä¼˜åŒ–çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘çš„6å°æ—¶è°ƒè¯•ç»å†ï¼Œå°±æ˜¯ä¸ºäº†è®©ä½ é¿å¼€æ‰€æœ‰å‘ï¼Œç›´æ¥ä¸Šæ‰‹ã€‚å¦‚æœä½ é‡åˆ°é—®é¢˜ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºäº¤æµâ€”â€”æˆ–è®¸æˆ‘ä»¬èƒ½ä¸€èµ·å®Œå–„å®ƒã€‚

ä½œä¸ºæ–°æ‰‹åšä¸»ï¼Œæˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¸®åŠ©æ›´å¤šäººã€‚å¦‚æœä½ å–œæ¬¢ï¼Œåˆ†äº«ç»™æœ‹å‹å§ï¼æœªæ¥ï¼Œæˆ‘è®¡åˆ’å½•åˆ¶è§†é¢‘æ•™ç¨‹ï¼Œè¿›ä¸€æ­¥ä¼ æ’­è¿™ä¸ªideaã€‚

âœ¨â€‹**æ¸©é¦¨æç¤º**â€‹âœ¨

> ä»¥ä¸Šæ‰€æœ‰ä»£ç å‡ä¸ºçº¯ç²¹çš„æœ¬åœ°åŒ–è„šæœ¬ï¼Œæ‰€æœ‰çš„æ•°æ®è¯»å–ã€å¤„ç†å’Œè®¡ç®—éƒ½åœ¨ä½ è‡ªå·±çš„è®¾å¤‡ä¸Šå®Œæˆã€‚
> â€‹æœ€å…³é”®çš„ä¸€ç‚¹ï¼š**å®ƒä¸ä¼šå°†ä½ çš„ä»»ä½•æ•°æ®ä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨ï¼â€‹**â€‹ä½ çš„æ‰€æœ‰æ•°æ®ï¼Œæ°¸è¿œåªå±äºä½ ã€‚

å¦‚æœä½ é‡åˆ°äº†ç¨‹åºé”™è¯¯ï¼Œæˆ–è€…çµå…‰ä¸€ç°æœ‰äº†è¶…æ£’çš„æƒ³æ³•ï¼Œéšæ—¶æ¬¢è¿å‘Šè¯‰æˆ‘ï¼

ğŸ“§ é‚®ä»¶ï¼š[Socrates.02zx@Gmail.com](mailto:Socrates.02zx@Gmail.com)

æ„Ÿè°¢é˜…è¯»ï¼Œä¸‹æ¬¡è§ï¼:)

>## sleep-logä»ªè¡¨ç›˜æ•ˆæœå›¾ï¼ˆç¤ºä¾‹ï¼‰

![dashboard-demo.png](https://i.setix.xyz/attachments/2025/sleep-log/sleep-log-01.png)
![dashboard-demo.png](https://i.setix.xyz/attachments/2025/sleep-log/sleep-log-02.png)
