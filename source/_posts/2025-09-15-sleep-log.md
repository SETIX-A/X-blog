---
layout: post
title: Obsidian ç¡çœ è‡ªåŠ¨åŒ–ç»ˆææŒ‡å—ï¼šä¸€é”®è¿½è¸ªä¸å¯è§†åŒ–
date: 2025-09-15
categories:
  - Obsidian
tags:
  - Obsidian
---


å¤§å®¶å¥½ï¼å¦‚æœä½ ä¹Ÿåœ¨ä¸ºè®°å½•ç¡çœ æ—¶é—´è€Œçƒ¦æ¼â€”â€”æ¯å¤©æ‰‹åŠ¨è¾“å…¥ã€è®¡ç®—æ—¶é•¿ï¼Œè¿˜å¾—è´¹åŠ›åœ°åˆ†ææ•°æ®â€”â€”é‚£ä¹ˆè¿™ç¯‡æ–‡ç« å°±æ˜¯ä¸ºä½ é‡èº«æ‰“é€ çš„ã€‚æˆ‘æ›¾ç»èŠ±äº†æ•°å°æ—¶è¸©éäº†å„ç§å‘ï¼Œæœ€ç»ˆæ­å»ºå‡ºè¿™å¥—**â€œæ™ºèƒ½â€**çš„Obsidianç¡çœ è¿½è¸ªç³»ç»Ÿã€‚

ç°åœ¨ï¼Œæˆ‘å°†ä¸€æ­¥æ­¥å¸¦ä½ å®ç°å®ƒã€‚åªéœ€15åˆ†é’Ÿï¼Œä½ å°±èƒ½äº«å—åˆ°**â€œä¸€ä¸ªæŒ‰é”®ï¼Œæå®šç¡è§‰ã€èµ·åºŠä¸å¤±çœ ä¿®æ­£â€**çš„æè‡´ä¾¿åˆ©ï¼Œä»¥åŠè‡ªåŠ¨ç”Ÿæˆçš„ç²¾ç¾ç¡çœ æ•°æ®å¯è§†åŒ–å›¾è¡¨ã€‚

ä¸ºä»€ä¹ˆé€‰æ‹©Obsidianï¼Ÿå®ƒå…è´¹ã€å¼€æºã€æ”¯æŒæ’ä»¶æ‰©å±•ï¼Œèƒ½å°†ä½ çš„ç¬”è®°åº“è½¬åŒ–ä¸ºå¼ºå¤§çš„ä¸ªäººæ•°æ®ç®¡ç†ç³»ç»Ÿã€‚è·Ÿéšæˆ‘çš„æŒ‡å—ï¼Œä½ å°†å­¦ä¼šå¦‚ä½•çœŸæ­£è®©å·¥å…·ä¸ºä½ æœåŠ¡ã€‚å‡†å¤‡å¥½äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å§ï¼

## æœ€ç»ˆæ•ˆæœé¢„è§ˆ

æƒ³è±¡ä¸€ä¸‹è¿™æ ·çš„åœºæ™¯ï¼š
1.  **æ™šä¸Šå‡†å¤‡ç¡è§‰æ—¶**ï¼šæŒ‰ä¸€ä¸ªå¿«æ·é”®ï¼Œç³»ç»Ÿè‡ªåŠ¨åœ¨ä½ çš„ç¡çœ æ—¥è®°ä¸­æ·»åŠ ä¸€è¡Œè®°å½•ï¼Œå¦‚ `- [date:: 2025-09-08], [bed:: 23:58], [wake:: ]`ã€‚å®ƒç”šè‡³èƒ½æ™ºèƒ½åˆ¤æ–­å‡Œæ™¨ç¡è§‰ï¼ˆä¾‹å¦‚å‡Œæ™¨3ç‚¹ï¼‰ï¼Œå¹¶å°†æ—¥æœŸå½’ä¸ºå‰ä¸€å¤©ã€‚
2.  **å¤±çœ æˆ–æ™šç¡æ—¶**ï¼šä¸ŠåºŠåè¿‡äº†1ã€2ä¸ªå°æ—¶æ‰ç¡ç€ï¼Ÿæ²¡å…³ç³»ï¼Œå†æ¬¡æŒ‰ä¸‹**åŒä¸€ä¸ªå¿«æ·é”®**ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ¤æ–­æ—¶é—´å·®è¿‡çŸ­ï¼Œå°†ä½ çš„å…¥ç¡æ—¶é—´**é™é»˜ä¿®æ­£**ä¸ºå½“å‰æ—¶é—´ã€‚
3.  **æ—©ä¸Šèµ·åºŠæ—¶**ï¼šå†æ¬¡æŒ‰ä¸‹**åŒä¸€ä¸ªå¿«æ·é”®**ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ¤æ–­ä½ å·²ç¡äº†è¶³å¤Ÿé•¿çš„æ—¶é—´ï¼Œæ‰¾åˆ°æ˜¨æ™šçš„è®°å½•ï¼Œè¡¥å…¨èµ·åºŠæ—¶é—´ï¼Œå¹¶ç²¾ç¡®è®¡ç®—å‡ºç¡çœ æ—¶é•¿ï¼Œå¦‚ `- [date:: 2025-09-08], [bed:: 23:58], [wake:: 08:15], [duration:: 08:17]`ã€‚
4.  **æ•°æ®å¯è§†åŒ–**ï¼šåœ¨ä»»æ„ç¬”è®°ä¸­ï¼Œéƒ½èƒ½çœ‹åˆ°è‡ªåŠ¨ç”Ÿæˆçš„ç¡çœ æ—¶é•¿è¶‹åŠ¿å›¾ã€å¹³å‡å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒå›¾ï¼Œä»¥åŠæŒ‰æœˆ/å¹´ç»Ÿè®¡è¡¨æ ¼ã€‚æ‰€æœ‰æ•°æ®å®æ—¶æ›´æ–°ï¼Œä¸€ç›®äº†ç„¶ã€‚

è¿™ä¸ä»…ä»…æ˜¯è®°å½•ï¼Œæ›´æ˜¯å¸®åŠ©ä½ ä¼˜åŒ–ç¡çœ ã€æå‡ç”Ÿæ´»è´¨é‡çš„å¼ºå¤§å·¥å…·ã€‚

> **ä»¥ä¸‹æ˜¯æ¼”ç¤ºå›¾**

![sleep-1.jpeg](https://i.setix.xyz/attachments/2025/09/sleep-1.jpeg)

## æ‰€éœ€å·¥å…·

- [Obsidian](https://obsidian.md/)ï¼ˆå…è´¹ä¸‹è½½è‡ªå®˜ç½‘ï¼‰ã€‚
- **æ’ä»¶**ï¼ˆåœ¨Obsidianè®¾ç½® > ç¤¾åŒºæ’ä»¶ä¸­å®‰è£…å¹¶å¯ç”¨ï¼‰ï¼š
  - **Templater**ï¼šæ ¸å¿ƒæ’ä»¶ï¼Œç”¨äºè¿è¡Œæˆ‘ä»¬çš„â€œæ™ºèƒ½è„šæœ¬â€ï¼Œå®ç°è‡ªåŠ¨åŒ–è®°å½•ã€‚
  - **Dataview**ï¼šç”¨äºæŸ¥è¯¢æ•°æ®å¹¶ç”Ÿæˆå›¾è¡¨ï¼Œæ”¯æŒåŠ¨æ€å¯è§†åŒ–ã€‚

å®‰è£…æ’ä»¶åï¼Œé‡å¯Obsidianä»¥ç¡®ä¿ç”Ÿæ•ˆã€‚

## Part 1: é…ç½®å”¯ä¸€çš„â€œæ™ºèƒ½ç¡çœ â€æ¨¡æ¿

æˆ‘ä»¬å°†æŠ›å¼ƒç¹ççš„â€œç¡è§‰/èµ·åºŠâ€åŒè„šæœ¬æ¨¡å¼ï¼Œç”¨ä¸€ä¸ª**ç»Ÿä¸€çš„ã€æ™ºèƒ½çš„**æ¨¡æ¿æ¥å¤„ç†æ‰€æœ‰åœºæ™¯ã€‚

é¦–å…ˆï¼Œåœ¨Obsidianè®¾ç½®ä¸­é…ç½®Templaterçš„æ¨¡æ¿æ–‡ä»¶å¤¹ï¼ˆä¾‹å¦‚åˆ›å»ºä¸€ä¸ªåä¸ºâ€œTemplatesâ€çš„æ–‡ä»¶å¤¹ï¼‰ã€‚

### æ™ºèƒ½ç¡çœ è„šæœ¬ (Smart-Sleep.md)

åœ¨ä½ çš„æ¨¡æ¿æ–‡ä»¶å¤¹ä¸‹åˆ›å»º`Smart-Sleep.md`æ–‡ä»¶ï¼Œç²˜è´´ä»¥ä¸‹**å®Œæ•´ä»£ç **ï¼š

```javascript
<%*
// --- æ™ºèƒ½ç¡çœ æ—¥å¿— V2.1 (è‡ªåŠ¨ä¿®æ­£ç‰ˆ) ---

// --- âš™ï¸ é…ç½®åŒº ---
const filePath = "ç¡çœ æ—¥è®°-2025.md"; // ä½ çš„ç¡çœ æ—¥å¿—æ–‡ä»¶åï¼ˆå¯è‡ªå®šä¹‰æ–‡ä»¶å¤¹ï¼Œå¦‚"6-è®°å½•/ç¡çœ /ç¡çœ æ—¥è®°-2025.md"ï¼‰
const morningCutoffHour = 5; // æ—©ä¸Š5ç‚¹å‰ç¡è§‰ï¼Œä»ç®—ä½œå‰ä¸€å¤©çš„ç¡çœ å‘¨æœŸ
const insomniaThresholdHours = 4; // ä¸ŠåºŠå4å°æ—¶å†…å†æ¬¡è§¦å‘ï¼Œå°†è‡ªåŠ¨ä¿®æ­£å…¥ç¡æ—¶é—´
// --- ç»“æŸé…ç½® ---

// --- æ ¸å¿ƒåŠŸèƒ½ ---
const file = tp.file.find_tfile(filePath);
if (!file) {
    new Notice(`âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ–‡ä»¶ "${filePath}"`, 5000);
    return;
}
const content = await app.vault.read(file);
const lines = content.trim().split('\n');
const lastLine = lines[lines.length - 1] || "";

if (lastLine.includes('[bed::') && lastLine.includes('[wake:: ]')) {
    await handleUnfinishedSleep(lastLine, lines.length - 1);
} else {
    await recordBedTime();
}

// --- å‡½æ•°å®šä¹‰ ---
async function handleUnfinishedSleep(line, lineIndex) {
    const bedMoment = getBedMoment(line);
    if (!bedMoment) return;
    
    const nowMoment = moment();
    const durationSinceBed = moment.duration(nowMoment.diff(bedMoment));

    if (durationSinceBed.asHours() <= insomniaThresholdHours) {
        await correctBedTime(line, lineIndex, nowMoment);
    } else {
        await recordWakeUp(line, lineIndex, bedMoment, nowMoment);
    }
}

async function recordBedTime() {
    const now = tp.date.now();
    const hour = parseInt(tp.date.now("H"));
    const dateString = (hour < morningCutoffHour) ? tp.date.now("YYYY-MM-DD", -1) : tp.date.now("YYYY-MM-DD");
    const bedTime = tp.date.now("HH:mm");
    const newEntry = `\n- [date:: ${dateString}], [bed:: ${bedTime}], [wake:: ]`;
    
    await app.vault.append(file, newEntry);
    new Notice(`ğŸ›Œ å·²è®°å½•ä¸ŠåºŠæ—¶é—´: ${bedTime}`, 3000);
}

async function recordWakeUp(line, lineIndex, bedMoment, wakeMoment) {
    const duration = moment.duration(wakeMoment.diff(bedMoment));
    const hours = Math.floor(duration.asHours());
    const minutes = duration.minutes();
    
    const wakeTimeFormatted = wakeMoment.format('HH:mm');
    const durationFormatted = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    
    const updatedLine = line.replace('[wake:: ]', `[wake:: ${wakeTimeFormatted}], [duration:: ${durationFormatted}]`);
    
    lines[lineIndex] = updatedLine;
    await app.vault.modify(file, lines.join('\n'));
    new Notice(`èµ·åºŠæˆåŠŸï¼ğŸ‰\nç¡çœ æ—¶é•¿: ${hours} å°æ—¶ ${minutes} åˆ†é’Ÿ`, 6000);
}

async function correctBedTime(line, lineIndex, newBedMoment) {
    const newBedTime = newBedMoment.format("HH:mm");
    const updatedLine = line.replace(/(\[bed:: )(\d{2}:\d{2})(\])/, `$1${newBedTime}$3`);

    lines[lineIndex] = updatedLine;
    await app.vault.modify(file, lines.join('\n'));
    new Notice(`â° å·²å°†å…¥ç¡æ—¶é—´è‡ªåŠ¨ä¿®æ­£ä¸º: ${newBedTime}`, 4000);
}

function getBedMoment(line) {
    const match = line.match(/\[date:: (.*?)\].*\[bed:: (.*?)\]/);
    if (!match || !match || !match) {
        new Notice("âŒ é”™è¯¯ï¼šæ— æ³•è§£ææœ€æ–°çš„ç¡çœ è®°å½•ã€‚", 5000);
        return null;
    }
    const dateStr = match;
    const bedTimeStr = match;
    
    const bedHour = parseInt(bedTimeStr.split(':'), 10);
    const bedDateAnchor = moment(dateStr, "YYYY-MM-DD");
    
    if (bedHour < morningCutoffHour) {
        bedDateAnchor.add(1, 'day');
    }
    
    return moment(`${bedDateAnchor.format('YYYY-MM-DD')} ${bedTimeStr}`, "YYYY-MM-DD HH:mm");
}
%>
```
> æç¤ºï¼šæµ‹è¯•å‰ï¼Œå…ˆåœ¨ä½ çš„ä»“åº“æ ¹ç›®å½•åˆ›å»ºä¸€ä¸ªç©ºçš„`ç¡çœ æ—¥è®°-2025.md`æ–‡ä»¶ï¼Œç¡®ä¿è·¯å¾„æ­£ç¡®ã€‚

### æ¨¡æ¿2ï¼šåˆ›å»ºä½ çš„æ—¥å¿—æ–‡ä»¶ (ç¡çœ æ—¥è®°-2025.md)

è¿™ä¸ªæ–‡ä»¶æ—¢æ˜¯ä½ çš„åŸå§‹æ•°æ®å­˜å‚¨åœ°ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå¿«é€Ÿé¢„è§ˆå’Œå¯¼èˆªçš„å…¥å£ã€‚

````markdown
```dataviewjs
// --- é…ç½®åŒº ---
const displayCount = 5; // å®šä¹‰æ˜¾ç¤ºçš„è¡Œæ•°ï¼Œå¯ä»»æ„ä¿®æ”¹ï¼
// --- é…ç½®åŒºç»“æŸ ---

const currentPage = dv.current();
if (currentPage && currentPage.file.lists.length > 0) {
    const recordCount = currentPage.file.lists.length;
    dv.paragraph(`ğŸ›Œ ç¡çœ è®°å½•å…±æœ‰ **${recordCount}** æ¡`);
    
    const clickableHeader = dv.el("h3", "æœ€è¿‘è®°å½• â¬");
    clickableHeader.style.cursor = "pointer"; 
    clickableHeader.onclick = () => {
        let scrollableContainer = dv.container;
        while (scrollableContainer && scrollableContainer.scrollHeight <= scrollableContainer.clientHeight) {
            scrollableContainer = scrollableContainer.parentElement;
        }
        if (scrollableContainer) {
            scrollableContainer.scrollTo({ top: scrollableContainer.scrollHeight, behavior: 'smooth' });
        }
    };
    
    const recentRecords = currentPage.file.lists.slice(-displayCount);
    dv.list(recentRecords.map(item => item.text));
} else {
    dv.paragraph("âŒ æš‚æ— ç¡çœ è®°å½•æ•°æ®ã€‚");
}
```

- [date:: 2025-08-01], [bed:: 23:30], [wake:: 09:50], [duration:: 10:20]ï¼ˆè¿™æ˜¯æ ¼å¼ç¤ºä¾‹ï¼Œä½ ä¸ç”¨æ‰‹åŠ¨è¾“å…¥ï¼‰
````
> `é‡è¦äº‹é¡¹`ï¼šè¯·ç¡®ä¿ä½ çš„**æ™ºèƒ½ç¡çœ è„šæœ¬**å’Œ**æ•°æ®å¯è§†åŒ–æŠ¥å‘Š**ï¼ˆè§Part 3ï¼‰é¡¶éƒ¨çš„`filePath`è·¯å¾„ï¼Œä¸ä½ è¿™ä¸ªæ—¥å¿—æ–‡ä»¶çš„**çœŸå®è·¯å¾„å’Œæ–‡ä»¶å**å®Œå…¨ä¸€è‡´ï¼è¿™æ˜¯æ•´ä¸ªç³»ç»Ÿèƒ½è¿ä½œèµ·æ¥çš„å…³é”®ã€‚

---

## Part 2: é…ç½®å¿«æ·å‘½ä»¤â€”â€”ä¸€é”®è§¦å‘æ‰€æœ‰æ“ä½œ

è®©è¿™ä¸ªæ™ºèƒ½è„šæœ¬å˜å¾—æ˜“ç”¨ã€‚æˆ‘ä»¬å°†ä¸ºå®ƒç»‘å®šä¸€ä¸ªå‘½ä»¤å’Œå¿«æ·é”®ã€‚

1. **è®¾ç½®Templateræ¨¡æ¿æ–‡ä»¶å¤¹**ï¼š
   - æ‰“å¼€Obsidianè®¾ç½® > ç¤¾åŒºæ’ä»¶ > Templaterã€‚
   - åœ¨â€œTemplate folder locationâ€ä¸­è¾“å…¥ä½ çš„æ¨¡æ¿æ–‡ä»¶å¤¹è·¯å¾„ï¼ˆå¦‚â€œTemplates/â€ï¼‰ã€‚

2. **æ·»åŠ å¿«æ·å‘½ä»¤**ï¼š
   - åœ¨Templaterè®¾ç½®ä¸­ï¼Œæ»šåŠ¨åˆ°â€œTemplate Hotkeysâ€ã€‚
   - ç‚¹å‡»â€œAdd newâ€ï¼Œé€‰æ‹©æˆ‘ä»¬åˆ›å»ºçš„`Smart-Sleep.md`æ¨¡æ¿ã€‚
   - **ä¸ºå®ƒåˆ†é…ä¸€ä¸ªä½ å–œæ¬¢çš„å¿«æ·é”®**ï¼ˆå¦‚`âŒ¥+S`ï¼‰ï¼Œå®ç°çœŸæ­£çš„ä¸€é”®æ“ä½œã€‚
   - ç°åœ¨ï¼ŒæŒ‰`âŒ˜+P`æ‰“å¼€å‘½ä»¤é¢æ¿ï¼Œæœç´¢â€œTemplater: Insert Smart-Sleepâ€ï¼Œæˆ–ç›´æ¥æŒ‰ä½ çš„å¿«æ·é”®ï¼Œå³å¯è¿è¡Œè„šæœ¬ã€‚

> æç¤ºï¼šä½ å¯ä»¥å‰å¾€â€œè®¾ç½®â€>â€œå‘½ä»¤é¢æ¿â€ï¼Œä½¿ç”¨ç½®é¡¶åŠŸèƒ½ï¼Œè®©ä½ çš„ç¡çœ å‘½ä»¤æ°¸è¿œå‡ºç°åœ¨æœ€å‰é¢ã€‚

## Part 3: æ•°æ®å¯è§†åŒ–â€”â€”ç”¨Dataviewç”Ÿæˆå›¾è¡¨

æœ€åä¸€æ­¥ï¼šè®©æ•°æ®â€œæ´»â€èµ·æ¥ï¼åœ¨ä½ çš„ä¸»é¡µæˆ–ä»»ä½•ç¬”è®°ä¸­æ’å…¥ä»¥ä¸‹DataviewJSä»£ç å—ï¼Œå®ƒä¼šè‡ªåŠ¨ç”Ÿæˆå¤šç§å›¾è¡¨å’Œç»Ÿè®¡ã€‚

<details>
<summary style="color: #4CAF50; font-weight: bold; cursor: pointer;">ğŸ“Š ç‚¹å‡»æŸ¥çœ‹/æŠ˜å ç¡çœ ç»Ÿè®¡æŠ¥å‘Šä»£ç </summary>

```dataviewjs
// --- é…ç½® ---
const FILE_PATH = "ç¡çœ æ—¥è®°-2025.md"; // ç¡®ä¿æ­¤è·¯å¾„ä¸ä½ çš„æ—¥å¿—æ–‡ä»¶å®Œå…¨ä¸€è‡´ï¼
// --- é…ç½®ç»“æŸ ---

// --- è¾…åŠ©å‡½æ•°ä¸å¸¸é‡ ---
const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const formatDurationFromMs = (ms) => {
    if (isNaN(ms) || ms < 0) return "æ— æ•ˆæ—¶é•¿";
    const totalMinutes = Math.round(ms / (1000 * 60));
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    return `${hours}æ—¶ ${minutes}åˆ†`;
};
const formatAvgDurationHours = (ms) => {
    if (isNaN(ms) || ms < 0) return "æ— æ•ˆ";
    return (ms / (1000 * 60 * 60)).toFixed(2);
};
const groupBy = (data, keyFn) => {
    return data.reduce((acc, item) => {
        const key = keyFn(item);
        if (!acc[key]) acc[key] = [];
        acc[key].push(item);
        return acc;
    }, {});
};
const calculateAverages = (group) => {
    const total = group.length;
    if (total === 0) return null;
    const avgDurationMs = group.reduce((sum, r) => sum + r.durationMillis, 0) / total;

    const calculateMeanTime = (times) => {
        if (times.length === 0) return null;
        const radians = times.map(t => (t / 24) * 2 * Math.PI);
        const sinSum = radians.reduce((sum, r) => sum + Math.sin(r), 0) / times.length;
        const cosSum = radians.reduce((sum, r) => sum + Math.cos(r), 0) / times.length;
        let meanAngle = Math.atan2(sinSum, cosSum);
        if (meanAngle < 0) meanAngle += 2 * Math.PI;
        let meanHours = (meanAngle / (2 * Math.PI)) * 24;
        const hours = Math.floor(meanHours);
        const minutes = Math.round((meanHours - hours) * 60);
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    };

    return {
        "è®°å½•å¤©æ•°": total,
        "å¹³å‡å…¥ç¡": calculateMeanTime(group.filter(r => r.bedtimeHour !== undefined).map(r => r.bedtimeHour)),
        "å¹³å‡èµ·åºŠ": calculateMeanTime(group.filter(r => r.waketimeHour !== undefined).map(r => r.waketimeHour)),
        "å¹³å‡æ—¶é•¿": formatDurationFromMs(avgDurationMs),
        "avgDurationMs": avgDurationMs
    };
};
// --- 1. æ•°æ®è§£ææ¨¡å— ---
function parseSleepData(page) {
    if (!page || !page.file || !page.file.lists || page.file.lists.length === 0) {
        dv.paragraph("âŒ **é”™è¯¯ï¼š** æ‰¾ä¸åˆ°æ–‡ä»¶æˆ–æ–‡ä»¶ä¸­æ²¡æœ‰æ•°æ®ã€‚");
        return null;
    }
    return page.file.lists
        .where(item => item.date && (item.duration || (item.bed && item.wake)))
        .map(item => {
            try {
                const dateStr = item.date.toString().substring(0, 10);
                let durationMillis, bedtimeHour, waketimeHour;

                if (item.duration) {
                    const [hours, minutes] = item.duration.toString().split(':').map(Number);
                    if (isNaN(hours) || isNaN(minutes)) return null;
                    durationMillis = (hours * 60 + minutes) * 60 * 1000;
                } else {
                    const bedtime = dv.date(`${dateStr}T${item.bed}`);
                    let waketime = dv.date(`${dateStr}T${item.wake}`);
                    if (!bedtime || !waketime) return null;
                    if (waketime <= bedtime) waketime = waketime.plus({ days: 1 });
                    durationMillis = waketime.toMillis() - bedtime.toMillis();
                }

                if (item.bed) {
                    const bedtime = dv.date(`${dateStr}T${item.bed}`);
                    if (bedtime) bedtimeHour = bedtime.hour + bedtime.minute / 60;
                }
                if (item.wake) {
                    const waketime = dv.date(`${dateStr}T${item.wake}`);
                    if (waketime) waketimeHour = waketime.hour + waketime.minute / 60;
                }

                return { date: dv.date(dateStr), durationMillis, bedtimeHour, waketimeHour };
            } catch (e) {
                console.warn(`[DataviewJS Sleep Report] è§£ææ•°æ®å¤±è´¥ï¼Œå·²è·³è¿‡æ­¤è¡Œ: ${item.text}`, e);
                return null;
            }
        })
        .filter(item => item !== null && !isNaN(item.durationMillis))
        .values;
}
// --- 2. æ ¸å¿ƒç»Ÿè®¡è®¡ç®—æ¨¡å— ---
function calculateAllStatistics(records) {
    const today = dv.date('now').startOf('day');
    const sevenDaysAgo = today.minus({ days: 7 }); 
    const thirtyDaysAgo = today.minus({ days: 30 }); 

    const stats = {
        recent7DaysRecords: [],
        recent30DaysRecords: [],
        byMonth: {},
        byYear: {},
        totalRecords: records.length,
    };

    for (const record of records) {
        const recordDate = record.date; 
        if (recordDate.ts >= thirtyDaysAgo.ts && recordDate.ts <= today.ts) {
            stats.recent30DaysRecords.push(record);
            if (recordDate.ts >= sevenDaysAgo.ts) {
                stats.recent7DaysRecords.push(record);
            }
        }
        const monthKey = recordDate.toFormat("yyyy-'å¹´' MM'-æœˆ'");
        if (!stats.byMonth[monthKey]) stats.byMonth[monthKey] = [];
        stats.byMonth[monthKey].push(record);

        const yearKey = recordDate.year;
        if (!stats.byYear[yearKey]) stats.byYear[yearKey] = [];
        stats.byYear[yearKey].push(record);
    }

    stats.sevenDayAvg = calculateAverages(stats.recent7DaysRecords);
    stats.thirtyDayAvg = calculateAverages(stats.recent30DaysRecords);
    stats.recent7DaysGrouped = groupBy(stats.recent7DaysRecords, r => r.date.toFormat("MM-dd"));
    stats.recent30DaysGrouped = groupBy(stats.recent30DaysRecords, r => r.date.toFormat("MM-dd"));
    stats.limitedMonthlyData = Object.fromEntries(Object.entries(stats.byMonth).sort((a, b) => b.localeCompare(a)).slice(0, 12));
    stats.limitedYearlyData = Object.fromEntries(Object.entries(stats.byYear).sort((a, b) => b.localeCompare(a)).slice(0, 12));

    return stats;
}
// --- 3. æŠ¥å‘Šæ¸²æŸ“æ¨¡å— ---
const calculateDistribution = (group, type) => {
    const hours = type === 'bedtime' ? group.map(r => r.bedtimeHour) : group.map(r => r.waketimeHour);
    const validHours = hours.filter(h => h !== undefined);
    const dist = {};
    validHours.forEach(h => {
        const bucket = `${String(Math.floor(h)).padStart(2, '0')}:00`;
        dist[bucket] = (dist[bucket] || 0) + 1;
    });
    return dist;
};
const renderTable = (header, data) => {
    const rows = Object.keys(data).sort((a, b) => b.localeCompare(a)).map(key => {
        const avg = calculateAverages(data[key]);
        return [avg.å¹³å‡æ—¶é•¿, avg.å¹³å‡å…¥ç¡ || "æ— æ•°æ®", avg.å¹³å‡èµ·åºŠ || "æ— æ•°æ®", key];
    });
    dv.table(["å¹³å‡æ—¶é•¿", "å¹³å‡å…¥ç¡", "å¹³å‡èµ·åºŠ", header], rows);
};
const createChartCanvas = () => {
    const canvas = dv.el("canvas");
    canvas.style.width = '100%'; canvas.style.height = '300px';
    canvas.width = window.innerWidth * window.devicePixelRatio; canvas.height = 300 * window.devicePixelRatio;
    dv.container.appendChild(canvas);
    return canvas.getContext('2d');
};
const renderAvgChart = (data, title) => {
    const labels = Object.keys(data).sort((a, b) => a.localeCompare(b));
    const chartValues = labels.map(key => (calculateAverages(data[key]).avgDurationMs / (1000 * 60 * 60)).toFixed(2));
    const ctx = createChartCanvas();
    new Chart(ctx, { type: 'bar', data: { labels, datasets: [{ label: `${title} å¹³å‡ç¡çœ æ—¶é•¿ (å°æ—¶)`, data: chartValues, backgroundColor: 'rgba(54, 162, 235, 0.2)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'å°æ—¶' } } }, animation: { duration: IS_IOS ? 0 : 1000 } } });
};
const renderTrendChart = (data, title, days) => {
    const labels = Object.keys(data).sort((a, b) => a.localeCompare(b));
    const chartValues = labels.map(key => formatAvgDurationHours(calculateAverages(data[key]).avgDurationMs));
    const ctx = createChartCanvas();
    new Chart(ctx, { type: 'line', data: { labels, datasets: [{ label: `${title} ç¡çœ æ—¶é•¿è¶‹åŠ¿ (å°æ—¶)`, data: chartValues, backgroundColor: 'rgba(255, 99, 132, 0.2)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 2, fill: false, tension: 0.3 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'å°æ—¶' } } }, animation: { duration: IS_IOS ? 0 : 1000 } } });
};
const renderStackedDistChart = (data, title) => {
    const bedtimeDist = calculateDistribution(data, 'bedtime');
    const waketimeDist = calculateDistribution(data, 'waketime');
    const allLabels = [...new Set([...Object.keys(bedtimeDist), ...Object.keys(waketimeDist)])].sort();
    const ctx = createChartCanvas();
    new Chart(ctx, { type: 'bar', data: { labels: allLabels, datasets: [{ label: 'å…¥ç¡æ—¶é—´', data: allLabels.map(label => bedtimeDist[label] || 0), backgroundColor: 'rgba(54, 162, 235, 0.4)', stack: 'Stack 0' }, { label: 'èµ·åºŠæ—¶é—´', data: allLabels.map(label => waketimeDist[label] || 0), backgroundColor: 'rgba(75, 192, 192, 0.4)', stack: 'Stack 0' }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { stacked: true }, y: { stacked: true } }, animation: { duration: IS_IOS ? 0 : 1000 } } });
};
function renderReport(stats) {
    if (stats.totalRecords === 0) {
        dv.paragraph("âœ… æ–‡ä»¶å·²æ‰¾åˆ°ï¼Œä½†æœªèƒ½è§£æå‡ºä»»ä½•æœ‰æ•ˆæ•°æ®è¡Œã€‚è¯·æ£€æŸ¥æ•°æ®æ ¼å¼ã€‚");
        return;
    }
    dv.header(4, `è¿‘7å¤©ç¡çœ è¶‹åŠ¿ å¹³å‡: ${stats.sevenDayAvg ? formatAvgDurationHours(stats.sevenDayAvg.avgDurationMs) : 'æ— æ•°æ®'}å°æ—¶`);
    renderTrendChart(stats.recent7DaysGrouped, "è¿‘7å¤©", 7);
    dv.header(4, `æœ€è¿‘30å¤©ç¡çœ æ—¶é•¿è¶‹åŠ¿ å¹³å‡: ${stats.thirtyDayAvg ? formatAvgDurationHours(stats.thirtyDayAvg.avgDurationMs) : 'æ— æ•°æ®'}å°æ—¶`);
    renderTrendChart(stats.recent30DaysGrouped, "æœ€è¿‘30å¤©", 30);
    dv.header(4, "æœ€è¿‘30å¤©å…¥ç¡/èµ·åºŠæ—¶é—´åˆ†å¸ƒ");
    renderStackedDistChart(stats.recent30DaysRecords, "æœ€è¿‘30å¤©");
    dv.header(3, "æŒ‰æœˆç»Ÿè®¡");
    renderTable("æœˆä»½", stats.limitedMonthlyData);
    renderAvgChart(stats.limitedMonthlyData, "æœˆ");
    dv.header(3, "æŒ‰å¹´ç»Ÿè®¡");
    renderTable("å¹´ä»½", stats.limitedYearlyData);
    renderAvgChart(stats.limitedYearlyData, "å¹´");
    dv.el('p', `ğŸ›Œ ç¡çœ è®°å½•å…± ${stats.totalRecords} æ¡`, { cls: 'sleep-record-count' });
}
// --- ä¸»æ‰§è¡Œé€»è¾‘ ---
const main = () => {
    const style = document.createElement('style');
    style.textContent = `
        .dataview.container { width: 100% !important; max-width: 100% !important; padding: 0 !important; margin: 0 !important; }
        canvas { width: 100% !important; max-height: 350px !important; }
        .sleep-record-count { font-size: 0.8em; color: var(--text-muted); text-align: left; margin-top: 15px; }
        @media (max-width: 600px) { canvas { max-height: 300px !important; } }
    `;
    document.head.appendChild(style);
    const page = dv.page(FILE_PATH);
    const records = parseSleepData(page);
    if (records) {
        const statistics = calculateAllStatistics(records);
        renderReport(statistics);
    }
};
if (typeof Chart === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js';
    document.head.appendChild(script);
    script.onload = main;
    script.onerror = () => dv.paragraph("âŒ æ— æ³•åŠ è½½ Chart.js åº“ï¼Œå›¾è¡¨æ— æ³•æ˜¾ç¤ºã€‚");
} else {
    main();
}
```
</details>

> æç¤ºï¼šä»£ç ä¼šä»CDNåŠ è½½Chart.jsï¼Œç¡®ä¿ä½ çš„Obsidianæœ‰ç½‘ç»œæƒé™ã€‚å¦‚æœå›¾è¡¨ä¸æ˜¾ç¤ºï¼Œæ£€æŸ¥æ–‡ä»¶è·¯å¾„å’Œæ•°æ®æ ¼å¼ã€‚

## ç»“è¯­

æ­å–œï¼ä½ ç°åœ¨æ‹¥æœ‰äº†ä¸€å¥—å®Œæ•´çš„Obsidianç¡çœ è‡ªåŠ¨åŒ–ç³»ç»Ÿã€‚ä»æ‰‹åŠ¨è®°å½•çš„çƒ¦æ¼ï¼Œåˆ°ä¸€é”®æ“ä½œå’Œæ™ºèƒ½å›¾è¡¨çš„ä¾¿åˆ©ï¼Œè¿™ä¸ä»…ä»…æ˜¯å·¥å…·ï¼Œæ›´æ˜¯ç”Ÿæ´»ä¼˜åŒ–çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘çš„6å°æ—¶è°ƒè¯•ç»å†ï¼Œå°±æ˜¯ä¸ºäº†è®©ä½ é¿å¼€æ‰€æœ‰å‘ï¼Œç›´æ¥ä¸Šæ‰‹ã€‚å¦‚æœä½ é‡åˆ°é—®é¢˜ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºäº¤æµâ€”â€”æˆ–è®¸æˆ‘ä»¬èƒ½ä¸€èµ·å®Œå–„å®ƒã€‚

ä½œä¸ºæ–°æ‰‹åšä¸»ï¼Œæˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¸®åŠ©æ›´å¤šäººã€‚å¦‚æœä½ å–œæ¬¢ï¼Œåˆ†äº«ç»™æœ‹å‹å§ï¼æœªæ¥ï¼Œæˆ‘è®¡åˆ’å½•åˆ¶è§†é¢‘æ•™ç¨‹ï¼Œè¿›ä¸€æ­¥ä¼ æ’­è¿™ä¸ªideaã€‚

âœ¨â€‹**æ¸©é¦¨æç¤º**â€‹âœ¨

> ä»¥ä¸Šä»£ç æ˜¯ä¸€ä¸ªçº¯ç²¹çš„æœ¬åœ°åŒ–æ•°æ®æŸ¥è¯¢ï¼Œæ‰€æœ‰æ•°æ®å¤„ç†éƒ½åœ¨ä½ è‡ªå·±çš„è®¾å¤‡ä¸Šå®Œæˆã€‚
> â€‹æœ€å…³é”®çš„ä¸€ç‚¹ï¼š**å®ƒä¸ä¼šå°†ä½ çš„ä»»ä½•æ•°æ®ä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨ï¼â€‹**â€‹

å¦‚æœä½ é‡åˆ°äº†ç¨‹åºé”™è¯¯ï¼Œæˆ–è€…çµå…‰ä¸€ç°æœ‰äº†è¶…æ£’çš„æƒ³æ³•ï¼Œéšæ—¶æ¬¢è¿å‘Šè¯‰æˆ‘ï¼

ğŸ“§ é‚®ä»¶ï¼š[Socrates.02zx@Gmail.com](mailto:Socrates.02zx@Gmail.com)

æ„Ÿè°¢é˜…è¯»ï¼Œä¸‹æ¬¡è§ï¼:)
